Grammar:

Rule 0     S' -> program
Rule 1     program -> error
Rule 2     program -> list
Rule 3     list -> list stmt
Rule 4     list -> list defn
Rule 5     list -> empty
Rule 6     asgn -> VAR MODEQ expr  [precedence=right, level=1]
Rule 7     asgn -> VAR DIVEQ expr  [precedence=right, level=1]
Rule 8     asgn -> VAR MULEQ expr  [precedence=right, level=1]
Rule 9     asgn -> VAR SUBEQ expr  [precedence=right, level=1]
Rule 10    asgn -> VAR ADDEQ expr  [precedence=right, level=1]
Rule 11    asgn -> VAR = expr  [precedence=right, level=1]
Rule 12    stmt -> { stmtlist }
Rule 13    stmt -> expr
Rule 14    stmt -> asgn
Rule 15    stmt -> IF ( expr ) stmt
Rule 16    stmt -> IF ( expr ) stmt ELSE stmt
Rule 17    stmt -> FOR ( expr ; expr ; expr ) stmt
Rule 18    stmt -> WHILE ( expr ) stmt
Rule 19    stmt -> PRINT prlist
Rule 20    stmt -> PROCEDURE ( arglist )
Rule 21    stmt -> RETURN expr
Rule 22    stmt -> RETURN
Rule 23    stmtlist -> stmtlist stmt
Rule 24    stmtlist -> empty
Rule 25    expr -> VAR DEC  [precedence=right, level=8]
Rule 26    expr -> VAR INC  [precedence=right, level=8]
Rule 27    expr -> DEC VAR
Rule 28    expr -> INC VAR
Rule 29    expr -> NOT expr  [precedence=right, level=8]
Rule 30    expr -> - expr  [precedence=right, level=8]
Rule 31    expr -> expr OR expr  [precedence=left, level=2]
Rule 32    expr -> expr AND expr  [precedence=left, level=3]
Rule 33    expr -> expr NE expr  [precedence=left, level=4]
Rule 34    expr -> expr EQ expr  [precedence=left, level=4]
Rule 35    expr -> expr GE expr  [precedence=left, level=5]
Rule 36    expr -> expr GT expr  [precedence=left, level=5]
Rule 37    expr -> expr LE expr  [precedence=left, level=5]
Rule 38    expr -> expr LT expr  [precedence=left, level=5]
Rule 39    expr -> expr ^ expr  [precedence=right, level=9]
Rule 40    expr -> expr % expr  [precedence=left, level=7]
Rule 41    expr -> expr / expr  [precedence=left, level=7]
Rule 42    expr -> expr * expr  [precedence=left, level=7]
Rule 43    expr -> expr - expr  [precedence=left, level=6]
Rule 44    expr -> expr + expr  [precedence=left, level=6]
Rule 45    expr -> ( expr )
Rule 46    expr -> BLTIN ( expr )
Rule 47    expr -> READ ( VAR )
Rule 48    expr -> FUNCTION ( arglist )
Rule 49    expr -> VAR
Rule 50    expr -> NUMBER
Rule 51    prlist -> prlist , STRING
Rule 52    prlist -> prlist , expr
Rule 53    prlist -> STRING
Rule 54    prlist -> expr
Rule 55    defn -> func_header ( ) stmt
Rule 56    func_header -> PROC procname
Rule 57    func_header -> FUNC procname
Rule 58    procname -> PROCEDURE
Rule 59    procname -> FUNCTION
Rule 60    procname -> VAR
Rule 61    arglist -> arglist , expr
Rule 62    arglist -> expr
Rule 63    arglist -> empty
Rule 64    empty -> <empty>

Unused terminals:

    ARG

Terminals, with rules where they appear:

%                    : 40
(                    : 15 16 17 18 20 45 46 47 48 55
)                    : 15 16 17 18 20 45 46 47 48 55
*                    : 42
+                    : 44
,                    : 51 52 61
-                    : 30 43
/                    : 41
;                    : 17 17
=                    : 11
ADDEQ                : 10
AND                  : 32
ARG                  : 
BLTIN                : 46
DEC                  : 25 27
DIVEQ                : 7
ELSE                 : 16
EQ                   : 34
FOR                  : 17
FUNC                 : 57
FUNCTION             : 48 59
GE                   : 35
GT                   : 36
IF                   : 15 16
INC                  : 26 28
LE                   : 37
LT                   : 38
MODEQ                : 6
MULEQ                : 8
NE                   : 33
NOT                  : 29
NUMBER               : 50
OR                   : 31
PRINT                : 19
PROC                 : 56
PROCEDURE            : 20 58
READ                 : 47
RETURN               : 21 22
STRING               : 51 53
SUBEQ                : 9
VAR                  : 6 7 8 9 10 11 25 26 27 28 47 49 60
WHILE                : 18
^                    : 39
error                : 1
{                    : 12
}                    : 12

Nonterminals, with rules where they appear:

arglist              : 20 48 61
asgn                 : 14
defn                 : 4
empty                : 5 24 63
expr                 : 6 7 8 9 10 11 13 15 16 17 17 17 18 21 29 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 46 52 54 61 62
func_header          : 55
list                 : 2 3 4
prlist               : 19 51 52
procname             : 56 57
program              : 0
stmt                 : 3 15 16 16 17 18 23 55
stmtlist             : 12 23


state 0

    (0) S' -> . program
    (1) program -> . error
    (2) program -> . list
    (3) list -> . list stmt
    (4) list -> . list defn
    (5) list -> . empty
    (64) empty -> .
    error           shift and go to state 2
    {               reduce using rule 64 (empty -> .)
    IF              reduce using rule 64 (empty -> .)
    FOR             reduce using rule 64 (empty -> .)
    WHILE           reduce using rule 64 (empty -> .)
    PRINT           reduce using rule 64 (empty -> .)
    PROCEDURE       reduce using rule 64 (empty -> .)
    RETURN          reduce using rule 64 (empty -> .)
    VAR             reduce using rule 64 (empty -> .)
    DEC             reduce using rule 64 (empty -> .)
    INC             reduce using rule 64 (empty -> .)
    NOT             reduce using rule 64 (empty -> .)
    -               reduce using rule 64 (empty -> .)
    (               reduce using rule 64 (empty -> .)
    BLTIN           reduce using rule 64 (empty -> .)
    READ            reduce using rule 64 (empty -> .)
    FUNCTION        reduce using rule 64 (empty -> .)
    NUMBER          reduce using rule 64 (empty -> .)
    PROC            reduce using rule 64 (empty -> .)
    FUNC            reduce using rule 64 (empty -> .)
    $end            reduce using rule 64 (empty -> .)

    program                        shift and go to state 1
    list                           shift and go to state 3
    empty                          shift and go to state 4

state 1

    (0) S' -> program .


state 2

    (1) program -> error .
    $end            reduce using rule 1 (program -> error .)


state 3

    (2) program -> list .
    (3) list -> list . stmt
    (4) list -> list . defn
    (12) stmt -> . { stmtlist }
    (13) stmt -> . expr
    (14) stmt -> . asgn
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . FOR ( expr ; expr ; expr ) stmt
    (18) stmt -> . WHILE ( expr ) stmt
    (19) stmt -> . PRINT prlist
    (20) stmt -> . PROCEDURE ( arglist )
    (21) stmt -> . RETURN expr
    (22) stmt -> . RETURN
    (55) defn -> . func_header ( ) stmt
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    (6) asgn -> . VAR MODEQ expr
    (7) asgn -> . VAR DIVEQ expr
    (8) asgn -> . VAR MULEQ expr
    (9) asgn -> . VAR SUBEQ expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR = expr
    (56) func_header -> . PROC procname
    (57) func_header -> . FUNC procname
    $end            reduce using rule 2 (program -> list .)
    {               shift and go to state 7
    IF              shift and go to state 10
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    PRINT           shift and go to state 14
    PROCEDURE       shift and go to state 15
    RETURN          shift and go to state 16
    VAR             shift and go to state 18
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26
    PROC            shift and go to state 27
    FUNC            shift and go to state 28

    stmt                           shift and go to state 5
    defn                           shift and go to state 6
    expr                           shift and go to state 8
    asgn                           shift and go to state 9
    func_header                    shift and go to state 17

state 4

    (5) list -> empty .
    {               reduce using rule 5 (list -> empty .)
    IF              reduce using rule 5 (list -> empty .)
    FOR             reduce using rule 5 (list -> empty .)
    WHILE           reduce using rule 5 (list -> empty .)
    PRINT           reduce using rule 5 (list -> empty .)
    PROCEDURE       reduce using rule 5 (list -> empty .)
    RETURN          reduce using rule 5 (list -> empty .)
    VAR             reduce using rule 5 (list -> empty .)
    DEC             reduce using rule 5 (list -> empty .)
    INC             reduce using rule 5 (list -> empty .)
    NOT             reduce using rule 5 (list -> empty .)
    -               reduce using rule 5 (list -> empty .)
    (               reduce using rule 5 (list -> empty .)
    BLTIN           reduce using rule 5 (list -> empty .)
    READ            reduce using rule 5 (list -> empty .)
    FUNCTION        reduce using rule 5 (list -> empty .)
    NUMBER          reduce using rule 5 (list -> empty .)
    PROC            reduce using rule 5 (list -> empty .)
    FUNC            reduce using rule 5 (list -> empty .)
    $end            reduce using rule 5 (list -> empty .)


state 5

    (3) list -> list stmt .
    {               reduce using rule 3 (list -> list stmt .)
    IF              reduce using rule 3 (list -> list stmt .)
    FOR             reduce using rule 3 (list -> list stmt .)
    WHILE           reduce using rule 3 (list -> list stmt .)
    PRINT           reduce using rule 3 (list -> list stmt .)
    PROCEDURE       reduce using rule 3 (list -> list stmt .)
    RETURN          reduce using rule 3 (list -> list stmt .)
    VAR             reduce using rule 3 (list -> list stmt .)
    DEC             reduce using rule 3 (list -> list stmt .)
    INC             reduce using rule 3 (list -> list stmt .)
    NOT             reduce using rule 3 (list -> list stmt .)
    -               reduce using rule 3 (list -> list stmt .)
    (               reduce using rule 3 (list -> list stmt .)
    BLTIN           reduce using rule 3 (list -> list stmt .)
    READ            reduce using rule 3 (list -> list stmt .)
    FUNCTION        reduce using rule 3 (list -> list stmt .)
    NUMBER          reduce using rule 3 (list -> list stmt .)
    PROC            reduce using rule 3 (list -> list stmt .)
    FUNC            reduce using rule 3 (list -> list stmt .)
    $end            reduce using rule 3 (list -> list stmt .)


state 6

    (4) list -> list defn .
    {               reduce using rule 4 (list -> list defn .)
    IF              reduce using rule 4 (list -> list defn .)
    FOR             reduce using rule 4 (list -> list defn .)
    WHILE           reduce using rule 4 (list -> list defn .)
    PRINT           reduce using rule 4 (list -> list defn .)
    PROCEDURE       reduce using rule 4 (list -> list defn .)
    RETURN          reduce using rule 4 (list -> list defn .)
    VAR             reduce using rule 4 (list -> list defn .)
    DEC             reduce using rule 4 (list -> list defn .)
    INC             reduce using rule 4 (list -> list defn .)
    NOT             reduce using rule 4 (list -> list defn .)
    -               reduce using rule 4 (list -> list defn .)
    (               reduce using rule 4 (list -> list defn .)
    BLTIN           reduce using rule 4 (list -> list defn .)
    READ            reduce using rule 4 (list -> list defn .)
    FUNCTION        reduce using rule 4 (list -> list defn .)
    NUMBER          reduce using rule 4 (list -> list defn .)
    PROC            reduce using rule 4 (list -> list defn .)
    FUNC            reduce using rule 4 (list -> list defn .)
    $end            reduce using rule 4 (list -> list defn .)


state 7

    (12) stmt -> { . stmtlist }
    (23) stmtlist -> . stmtlist stmt
    (24) stmtlist -> . empty
    (64) empty -> .
    }               reduce using rule 64 (empty -> .)
    {               reduce using rule 64 (empty -> .)
    IF              reduce using rule 64 (empty -> .)
    FOR             reduce using rule 64 (empty -> .)
    WHILE           reduce using rule 64 (empty -> .)
    PRINT           reduce using rule 64 (empty -> .)
    PROCEDURE       reduce using rule 64 (empty -> .)
    RETURN          reduce using rule 64 (empty -> .)
    VAR             reduce using rule 64 (empty -> .)
    DEC             reduce using rule 64 (empty -> .)
    INC             reduce using rule 64 (empty -> .)
    NOT             reduce using rule 64 (empty -> .)
    -               reduce using rule 64 (empty -> .)
    (               reduce using rule 64 (empty -> .)
    BLTIN           reduce using rule 64 (empty -> .)
    READ            reduce using rule 64 (empty -> .)
    FUNCTION        reduce using rule 64 (empty -> .)
    NUMBER          reduce using rule 64 (empty -> .)

    stmtlist                       shift and go to state 29
    empty                          shift and go to state 30

state 8

    (13) stmt -> expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
  ! shift/reduce conflict for - resolved as shift
    {               reduce using rule 13 (stmt -> expr .)
    IF              reduce using rule 13 (stmt -> expr .)
    FOR             reduce using rule 13 (stmt -> expr .)
    WHILE           reduce using rule 13 (stmt -> expr .)
    PRINT           reduce using rule 13 (stmt -> expr .)
    PROCEDURE       reduce using rule 13 (stmt -> expr .)
    RETURN          reduce using rule 13 (stmt -> expr .)
    VAR             reduce using rule 13 (stmt -> expr .)
    DEC             reduce using rule 13 (stmt -> expr .)
    INC             reduce using rule 13 (stmt -> expr .)
    NOT             reduce using rule 13 (stmt -> expr .)
    (               reduce using rule 13 (stmt -> expr .)
    BLTIN           reduce using rule 13 (stmt -> expr .)
    READ            reduce using rule 13 (stmt -> expr .)
    FUNCTION        reduce using rule 13 (stmt -> expr .)
    NUMBER          reduce using rule 13 (stmt -> expr .)
    PROC            reduce using rule 13 (stmt -> expr .)
    FUNC            reduce using rule 13 (stmt -> expr .)
    $end            reduce using rule 13 (stmt -> expr .)
    }               reduce using rule 13 (stmt -> expr .)
    ELSE            reduce using rule 13 (stmt -> expr .)
    OR              shift and go to state 31
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 9

    (14) stmt -> asgn .
    {               reduce using rule 14 (stmt -> asgn .)
    IF              reduce using rule 14 (stmt -> asgn .)
    FOR             reduce using rule 14 (stmt -> asgn .)
    WHILE           reduce using rule 14 (stmt -> asgn .)
    PRINT           reduce using rule 14 (stmt -> asgn .)
    PROCEDURE       reduce using rule 14 (stmt -> asgn .)
    RETURN          reduce using rule 14 (stmt -> asgn .)
    VAR             reduce using rule 14 (stmt -> asgn .)
    DEC             reduce using rule 14 (stmt -> asgn .)
    INC             reduce using rule 14 (stmt -> asgn .)
    NOT             reduce using rule 14 (stmt -> asgn .)
    -               reduce using rule 14 (stmt -> asgn .)
    (               reduce using rule 14 (stmt -> asgn .)
    BLTIN           reduce using rule 14 (stmt -> asgn .)
    READ            reduce using rule 14 (stmt -> asgn .)
    FUNCTION        reduce using rule 14 (stmt -> asgn .)
    NUMBER          reduce using rule 14 (stmt -> asgn .)
    PROC            reduce using rule 14 (stmt -> asgn .)
    FUNC            reduce using rule 14 (stmt -> asgn .)
    $end            reduce using rule 14 (stmt -> asgn .)
    }               reduce using rule 14 (stmt -> asgn .)
    ELSE            reduce using rule 14 (stmt -> asgn .)


state 10

    (15) stmt -> IF . ( expr ) stmt
    (16) stmt -> IF . ( expr ) stmt ELSE stmt
    (               shift and go to state 45


state 11

    (45) expr -> ( . expr )
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 46

state 12

    (17) stmt -> FOR . ( expr ; expr ; expr ) stmt
    (               shift and go to state 48


state 13

    (18) stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 49


state 14

    (19) stmt -> PRINT . prlist
    (51) prlist -> . prlist , STRING
    (52) prlist -> . prlist , expr
    (53) prlist -> . STRING
    (54) prlist -> . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    STRING          shift and go to state 51
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    prlist                         shift and go to state 50
    expr                           shift and go to state 52

state 15

    (20) stmt -> PROCEDURE . ( arglist )
    (               shift and go to state 53


state 16

    (21) stmt -> RETURN . expr
    (22) stmt -> RETURN .
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for BLTIN resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
    {               reduce using rule 22 (stmt -> RETURN .)
    IF              reduce using rule 22 (stmt -> RETURN .)
    FOR             reduce using rule 22 (stmt -> RETURN .)
    WHILE           reduce using rule 22 (stmt -> RETURN .)
    PRINT           reduce using rule 22 (stmt -> RETURN .)
    PROCEDURE       reduce using rule 22 (stmt -> RETURN .)
    RETURN          reduce using rule 22 (stmt -> RETURN .)
    PROC            reduce using rule 22 (stmt -> RETURN .)
    FUNC            reduce using rule 22 (stmt -> RETURN .)
    $end            reduce using rule 22 (stmt -> RETURN .)
    }               reduce using rule 22 (stmt -> RETURN .)
    ELSE            reduce using rule 22 (stmt -> RETURN .)
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 54

state 17

    (55) defn -> func_header . ( ) stmt
    (               shift and go to state 55


state 18

    (25) expr -> VAR . DEC
    (26) expr -> VAR . INC
    (49) expr -> VAR .
    (6) asgn -> VAR . MODEQ expr
    (7) asgn -> VAR . DIVEQ expr
    (8) asgn -> VAR . MULEQ expr
    (9) asgn -> VAR . SUBEQ expr
    (10) asgn -> VAR . ADDEQ expr
    (11) asgn -> VAR . = expr
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INC resolved as shift
    DEC             shift and go to state 56
    INC             shift and go to state 57
    OR              reduce using rule 49 (expr -> VAR .)
    AND             reduce using rule 49 (expr -> VAR .)
    NE              reduce using rule 49 (expr -> VAR .)
    EQ              reduce using rule 49 (expr -> VAR .)
    GE              reduce using rule 49 (expr -> VAR .)
    GT              reduce using rule 49 (expr -> VAR .)
    LE              reduce using rule 49 (expr -> VAR .)
    LT              reduce using rule 49 (expr -> VAR .)
    ^               reduce using rule 49 (expr -> VAR .)
    %               reduce using rule 49 (expr -> VAR .)
    /               reduce using rule 49 (expr -> VAR .)
    *               reduce using rule 49 (expr -> VAR .)
    -               reduce using rule 49 (expr -> VAR .)
    +               reduce using rule 49 (expr -> VAR .)
    {               reduce using rule 49 (expr -> VAR .)
    IF              reduce using rule 49 (expr -> VAR .)
    FOR             reduce using rule 49 (expr -> VAR .)
    WHILE           reduce using rule 49 (expr -> VAR .)
    PRINT           reduce using rule 49 (expr -> VAR .)
    PROCEDURE       reduce using rule 49 (expr -> VAR .)
    RETURN          reduce using rule 49 (expr -> VAR .)
    VAR             reduce using rule 49 (expr -> VAR .)
    NOT             reduce using rule 49 (expr -> VAR .)
    (               reduce using rule 49 (expr -> VAR .)
    BLTIN           reduce using rule 49 (expr -> VAR .)
    READ            reduce using rule 49 (expr -> VAR .)
    FUNCTION        reduce using rule 49 (expr -> VAR .)
    NUMBER          reduce using rule 49 (expr -> VAR .)
    PROC            reduce using rule 49 (expr -> VAR .)
    FUNC            reduce using rule 49 (expr -> VAR .)
    $end            reduce using rule 49 (expr -> VAR .)
    }               reduce using rule 49 (expr -> VAR .)
    ELSE            reduce using rule 49 (expr -> VAR .)
    MODEQ           shift and go to state 58
    DIVEQ           shift and go to state 59
    MULEQ           shift and go to state 60
    SUBEQ           shift and go to state 61
    ADDEQ           shift and go to state 62
    =               shift and go to state 63


state 19

    (27) expr -> DEC . VAR
    VAR             shift and go to state 64


state 20

    (28) expr -> INC . VAR
    VAR             shift and go to state 65


state 21

    (29) expr -> NOT . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 66

state 22

    (30) expr -> - . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 67

state 23

    (46) expr -> BLTIN . ( expr )
    (               shift and go to state 68


state 24

    (47) expr -> READ . ( VAR )
    (               shift and go to state 69


state 25

    (48) expr -> FUNCTION . ( arglist )
    (               shift and go to state 70


state 26

    (50) expr -> NUMBER .
    OR              reduce using rule 50 (expr -> NUMBER .)
    AND             reduce using rule 50 (expr -> NUMBER .)
    NE              reduce using rule 50 (expr -> NUMBER .)
    EQ              reduce using rule 50 (expr -> NUMBER .)
    GE              reduce using rule 50 (expr -> NUMBER .)
    GT              reduce using rule 50 (expr -> NUMBER .)
    LE              reduce using rule 50 (expr -> NUMBER .)
    LT              reduce using rule 50 (expr -> NUMBER .)
    ^               reduce using rule 50 (expr -> NUMBER .)
    %               reduce using rule 50 (expr -> NUMBER .)
    /               reduce using rule 50 (expr -> NUMBER .)
    *               reduce using rule 50 (expr -> NUMBER .)
    -               reduce using rule 50 (expr -> NUMBER .)
    +               reduce using rule 50 (expr -> NUMBER .)
    {               reduce using rule 50 (expr -> NUMBER .)
    IF              reduce using rule 50 (expr -> NUMBER .)
    FOR             reduce using rule 50 (expr -> NUMBER .)
    WHILE           reduce using rule 50 (expr -> NUMBER .)
    PRINT           reduce using rule 50 (expr -> NUMBER .)
    PROCEDURE       reduce using rule 50 (expr -> NUMBER .)
    RETURN          reduce using rule 50 (expr -> NUMBER .)
    VAR             reduce using rule 50 (expr -> NUMBER .)
    DEC             reduce using rule 50 (expr -> NUMBER .)
    INC             reduce using rule 50 (expr -> NUMBER .)
    NOT             reduce using rule 50 (expr -> NUMBER .)
    (               reduce using rule 50 (expr -> NUMBER .)
    BLTIN           reduce using rule 50 (expr -> NUMBER .)
    READ            reduce using rule 50 (expr -> NUMBER .)
    FUNCTION        reduce using rule 50 (expr -> NUMBER .)
    NUMBER          reduce using rule 50 (expr -> NUMBER .)
    PROC            reduce using rule 50 (expr -> NUMBER .)
    FUNC            reduce using rule 50 (expr -> NUMBER .)
    $end            reduce using rule 50 (expr -> NUMBER .)
    )               reduce using rule 50 (expr -> NUMBER .)
    ,               reduce using rule 50 (expr -> NUMBER .)
    }               reduce using rule 50 (expr -> NUMBER .)
    ELSE            reduce using rule 50 (expr -> NUMBER .)
    ;               reduce using rule 50 (expr -> NUMBER .)


state 27

    (56) func_header -> PROC . procname
    (58) procname -> . PROCEDURE
    (59) procname -> . FUNCTION
    (60) procname -> . VAR
    PROCEDURE       shift and go to state 72
    FUNCTION        shift and go to state 73
    VAR             shift and go to state 74

    procname                       shift and go to state 71

state 28

    (57) func_header -> FUNC . procname
    (58) procname -> . PROCEDURE
    (59) procname -> . FUNCTION
    (60) procname -> . VAR
    PROCEDURE       shift and go to state 72
    FUNCTION        shift and go to state 73
    VAR             shift and go to state 74

    procname                       shift and go to state 75

state 29

    (12) stmt -> { stmtlist . }
    (23) stmtlist -> stmtlist . stmt
    (12) stmt -> . { stmtlist }
    (13) stmt -> . expr
    (14) stmt -> . asgn
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . FOR ( expr ; expr ; expr ) stmt
    (18) stmt -> . WHILE ( expr ) stmt
    (19) stmt -> . PRINT prlist
    (20) stmt -> . PROCEDURE ( arglist )
    (21) stmt -> . RETURN expr
    (22) stmt -> . RETURN
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    (6) asgn -> . VAR MODEQ expr
    (7) asgn -> . VAR DIVEQ expr
    (8) asgn -> . VAR MULEQ expr
    (9) asgn -> . VAR SUBEQ expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR = expr
    }               shift and go to state 76
    {               shift and go to state 7
    IF              shift and go to state 10
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    PRINT           shift and go to state 14
    PROCEDURE       shift and go to state 15
    RETURN          shift and go to state 16
    VAR             shift and go to state 18
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    stmt                           shift and go to state 77
    expr                           shift and go to state 8
    asgn                           shift and go to state 9

state 30

    (24) stmtlist -> empty .
    }               reduce using rule 24 (stmtlist -> empty .)
    {               reduce using rule 24 (stmtlist -> empty .)
    IF              reduce using rule 24 (stmtlist -> empty .)
    FOR             reduce using rule 24 (stmtlist -> empty .)
    WHILE           reduce using rule 24 (stmtlist -> empty .)
    PRINT           reduce using rule 24 (stmtlist -> empty .)
    PROCEDURE       reduce using rule 24 (stmtlist -> empty .)
    RETURN          reduce using rule 24 (stmtlist -> empty .)
    VAR             reduce using rule 24 (stmtlist -> empty .)
    DEC             reduce using rule 24 (stmtlist -> empty .)
    INC             reduce using rule 24 (stmtlist -> empty .)
    NOT             reduce using rule 24 (stmtlist -> empty .)
    -               reduce using rule 24 (stmtlist -> empty .)
    (               reduce using rule 24 (stmtlist -> empty .)
    BLTIN           reduce using rule 24 (stmtlist -> empty .)
    READ            reduce using rule 24 (stmtlist -> empty .)
    FUNCTION        reduce using rule 24 (stmtlist -> empty .)
    NUMBER          reduce using rule 24 (stmtlist -> empty .)


state 31

    (31) expr -> expr OR . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 78

state 32

    (32) expr -> expr AND . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 79

state 33

    (33) expr -> expr NE . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 80

state 34

    (34) expr -> expr EQ . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 81

state 35

    (35) expr -> expr GE . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 82

state 36

    (36) expr -> expr GT . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 83

state 37

    (37) expr -> expr LE . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 84

state 38

    (38) expr -> expr LT . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 85

state 39

    (39) expr -> expr ^ . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 86

state 40

    (40) expr -> expr % . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 87

state 41

    (41) expr -> expr / . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 88

state 42

    (42) expr -> expr * . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 89

state 43

    (43) expr -> expr - . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 90

state 44

    (44) expr -> expr + . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 91

state 45

    (15) stmt -> IF ( . expr ) stmt
    (16) stmt -> IF ( . expr ) stmt ELSE stmt
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 92

state 46

    (45) expr -> ( expr . )
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    )               shift and go to state 93
    OR              shift and go to state 31
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 47

    (25) expr -> VAR . DEC
    (26) expr -> VAR . INC
    (49) expr -> VAR .
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INC resolved as shift
    DEC             shift and go to state 56
    INC             shift and go to state 57
    )               reduce using rule 49 (expr -> VAR .)
    OR              reduce using rule 49 (expr -> VAR .)
    AND             reduce using rule 49 (expr -> VAR .)
    NE              reduce using rule 49 (expr -> VAR .)
    EQ              reduce using rule 49 (expr -> VAR .)
    GE              reduce using rule 49 (expr -> VAR .)
    GT              reduce using rule 49 (expr -> VAR .)
    LE              reduce using rule 49 (expr -> VAR .)
    LT              reduce using rule 49 (expr -> VAR .)
    ^               reduce using rule 49 (expr -> VAR .)
    %               reduce using rule 49 (expr -> VAR .)
    /               reduce using rule 49 (expr -> VAR .)
    *               reduce using rule 49 (expr -> VAR .)
    -               reduce using rule 49 (expr -> VAR .)
    +               reduce using rule 49 (expr -> VAR .)
    ,               reduce using rule 49 (expr -> VAR .)
    {               reduce using rule 49 (expr -> VAR .)
    IF              reduce using rule 49 (expr -> VAR .)
    FOR             reduce using rule 49 (expr -> VAR .)
    WHILE           reduce using rule 49 (expr -> VAR .)
    PRINT           reduce using rule 49 (expr -> VAR .)
    PROCEDURE       reduce using rule 49 (expr -> VAR .)
    RETURN          reduce using rule 49 (expr -> VAR .)
    VAR             reduce using rule 49 (expr -> VAR .)
    NOT             reduce using rule 49 (expr -> VAR .)
    (               reduce using rule 49 (expr -> VAR .)
    BLTIN           reduce using rule 49 (expr -> VAR .)
    READ            reduce using rule 49 (expr -> VAR .)
    FUNCTION        reduce using rule 49 (expr -> VAR .)
    NUMBER          reduce using rule 49 (expr -> VAR .)
    PROC            reduce using rule 49 (expr -> VAR .)
    FUNC            reduce using rule 49 (expr -> VAR .)
    $end            reduce using rule 49 (expr -> VAR .)
    }               reduce using rule 49 (expr -> VAR .)
    ELSE            reduce using rule 49 (expr -> VAR .)
    ;               reduce using rule 49 (expr -> VAR .)


state 48

    (17) stmt -> FOR ( . expr ; expr ; expr ) stmt
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 94

state 49

    (18) stmt -> WHILE ( . expr ) stmt
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 95

state 50

    (19) stmt -> PRINT prlist .
    (51) prlist -> prlist . , STRING
    (52) prlist -> prlist . , expr
    {               reduce using rule 19 (stmt -> PRINT prlist .)
    IF              reduce using rule 19 (stmt -> PRINT prlist .)
    FOR             reduce using rule 19 (stmt -> PRINT prlist .)
    WHILE           reduce using rule 19 (stmt -> PRINT prlist .)
    PRINT           reduce using rule 19 (stmt -> PRINT prlist .)
    PROCEDURE       reduce using rule 19 (stmt -> PRINT prlist .)
    RETURN          reduce using rule 19 (stmt -> PRINT prlist .)
    VAR             reduce using rule 19 (stmt -> PRINT prlist .)
    DEC             reduce using rule 19 (stmt -> PRINT prlist .)
    INC             reduce using rule 19 (stmt -> PRINT prlist .)
    NOT             reduce using rule 19 (stmt -> PRINT prlist .)
    -               reduce using rule 19 (stmt -> PRINT prlist .)
    (               reduce using rule 19 (stmt -> PRINT prlist .)
    BLTIN           reduce using rule 19 (stmt -> PRINT prlist .)
    READ            reduce using rule 19 (stmt -> PRINT prlist .)
    FUNCTION        reduce using rule 19 (stmt -> PRINT prlist .)
    NUMBER          reduce using rule 19 (stmt -> PRINT prlist .)
    PROC            reduce using rule 19 (stmt -> PRINT prlist .)
    FUNC            reduce using rule 19 (stmt -> PRINT prlist .)
    $end            reduce using rule 19 (stmt -> PRINT prlist .)
    }               reduce using rule 19 (stmt -> PRINT prlist .)
    ELSE            reduce using rule 19 (stmt -> PRINT prlist .)
    ,               shift and go to state 96


state 51

    (53) prlist -> STRING .
    ,               reduce using rule 53 (prlist -> STRING .)
    {               reduce using rule 53 (prlist -> STRING .)
    IF              reduce using rule 53 (prlist -> STRING .)
    FOR             reduce using rule 53 (prlist -> STRING .)
    WHILE           reduce using rule 53 (prlist -> STRING .)
    PRINT           reduce using rule 53 (prlist -> STRING .)
    PROCEDURE       reduce using rule 53 (prlist -> STRING .)
    RETURN          reduce using rule 53 (prlist -> STRING .)
    VAR             reduce using rule 53 (prlist -> STRING .)
    DEC             reduce using rule 53 (prlist -> STRING .)
    INC             reduce using rule 53 (prlist -> STRING .)
    NOT             reduce using rule 53 (prlist -> STRING .)
    -               reduce using rule 53 (prlist -> STRING .)
    (               reduce using rule 53 (prlist -> STRING .)
    BLTIN           reduce using rule 53 (prlist -> STRING .)
    READ            reduce using rule 53 (prlist -> STRING .)
    FUNCTION        reduce using rule 53 (prlist -> STRING .)
    NUMBER          reduce using rule 53 (prlist -> STRING .)
    PROC            reduce using rule 53 (prlist -> STRING .)
    FUNC            reduce using rule 53 (prlist -> STRING .)
    $end            reduce using rule 53 (prlist -> STRING .)
    }               reduce using rule 53 (prlist -> STRING .)
    ELSE            reduce using rule 53 (prlist -> STRING .)


state 52

    (54) prlist -> expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
  ! shift/reduce conflict for - resolved as shift
    ,               reduce using rule 54 (prlist -> expr .)
    {               reduce using rule 54 (prlist -> expr .)
    IF              reduce using rule 54 (prlist -> expr .)
    FOR             reduce using rule 54 (prlist -> expr .)
    WHILE           reduce using rule 54 (prlist -> expr .)
    PRINT           reduce using rule 54 (prlist -> expr .)
    PROCEDURE       reduce using rule 54 (prlist -> expr .)
    RETURN          reduce using rule 54 (prlist -> expr .)
    VAR             reduce using rule 54 (prlist -> expr .)
    DEC             reduce using rule 54 (prlist -> expr .)
    INC             reduce using rule 54 (prlist -> expr .)
    NOT             reduce using rule 54 (prlist -> expr .)
    (               reduce using rule 54 (prlist -> expr .)
    BLTIN           reduce using rule 54 (prlist -> expr .)
    READ            reduce using rule 54 (prlist -> expr .)
    FUNCTION        reduce using rule 54 (prlist -> expr .)
    NUMBER          reduce using rule 54 (prlist -> expr .)
    PROC            reduce using rule 54 (prlist -> expr .)
    FUNC            reduce using rule 54 (prlist -> expr .)
    $end            reduce using rule 54 (prlist -> expr .)
    }               reduce using rule 54 (prlist -> expr .)
    ELSE            reduce using rule 54 (prlist -> expr .)
    OR              shift and go to state 31
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 53

    (20) stmt -> PROCEDURE ( . arglist )
    (61) arglist -> . arglist , expr
    (62) arglist -> . expr
    (63) arglist -> . empty
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    (64) empty -> .
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26
    )               reduce using rule 64 (empty -> .)
    ,               reduce using rule 64 (empty -> .)

    arglist                        shift and go to state 97
    expr                           shift and go to state 98
    empty                          shift and go to state 99

state 54

    (21) stmt -> RETURN expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
  ! shift/reduce conflict for - resolved as shift
    {               reduce using rule 21 (stmt -> RETURN expr .)
    IF              reduce using rule 21 (stmt -> RETURN expr .)
    FOR             reduce using rule 21 (stmt -> RETURN expr .)
    WHILE           reduce using rule 21 (stmt -> RETURN expr .)
    PRINT           reduce using rule 21 (stmt -> RETURN expr .)
    PROCEDURE       reduce using rule 21 (stmt -> RETURN expr .)
    RETURN          reduce using rule 21 (stmt -> RETURN expr .)
    VAR             reduce using rule 21 (stmt -> RETURN expr .)
    DEC             reduce using rule 21 (stmt -> RETURN expr .)
    INC             reduce using rule 21 (stmt -> RETURN expr .)
    NOT             reduce using rule 21 (stmt -> RETURN expr .)
    (               reduce using rule 21 (stmt -> RETURN expr .)
    BLTIN           reduce using rule 21 (stmt -> RETURN expr .)
    READ            reduce using rule 21 (stmt -> RETURN expr .)
    FUNCTION        reduce using rule 21 (stmt -> RETURN expr .)
    NUMBER          reduce using rule 21 (stmt -> RETURN expr .)
    PROC            reduce using rule 21 (stmt -> RETURN expr .)
    FUNC            reduce using rule 21 (stmt -> RETURN expr .)
    $end            reduce using rule 21 (stmt -> RETURN expr .)
    }               reduce using rule 21 (stmt -> RETURN expr .)
    ELSE            reduce using rule 21 (stmt -> RETURN expr .)
    OR              shift and go to state 31
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 55

    (55) defn -> func_header ( . ) stmt
    )               shift and go to state 100


state 56

    (25) expr -> VAR DEC .
    OR              reduce using rule 25 (expr -> VAR DEC .)
    AND             reduce using rule 25 (expr -> VAR DEC .)
    NE              reduce using rule 25 (expr -> VAR DEC .)
    EQ              reduce using rule 25 (expr -> VAR DEC .)
    GE              reduce using rule 25 (expr -> VAR DEC .)
    GT              reduce using rule 25 (expr -> VAR DEC .)
    LE              reduce using rule 25 (expr -> VAR DEC .)
    LT              reduce using rule 25 (expr -> VAR DEC .)
    ^               reduce using rule 25 (expr -> VAR DEC .)
    %               reduce using rule 25 (expr -> VAR DEC .)
    /               reduce using rule 25 (expr -> VAR DEC .)
    *               reduce using rule 25 (expr -> VAR DEC .)
    -               reduce using rule 25 (expr -> VAR DEC .)
    +               reduce using rule 25 (expr -> VAR DEC .)
    {               reduce using rule 25 (expr -> VAR DEC .)
    IF              reduce using rule 25 (expr -> VAR DEC .)
    FOR             reduce using rule 25 (expr -> VAR DEC .)
    WHILE           reduce using rule 25 (expr -> VAR DEC .)
    PRINT           reduce using rule 25 (expr -> VAR DEC .)
    PROCEDURE       reduce using rule 25 (expr -> VAR DEC .)
    RETURN          reduce using rule 25 (expr -> VAR DEC .)
    VAR             reduce using rule 25 (expr -> VAR DEC .)
    DEC             reduce using rule 25 (expr -> VAR DEC .)
    INC             reduce using rule 25 (expr -> VAR DEC .)
    NOT             reduce using rule 25 (expr -> VAR DEC .)
    (               reduce using rule 25 (expr -> VAR DEC .)
    BLTIN           reduce using rule 25 (expr -> VAR DEC .)
    READ            reduce using rule 25 (expr -> VAR DEC .)
    FUNCTION        reduce using rule 25 (expr -> VAR DEC .)
    NUMBER          reduce using rule 25 (expr -> VAR DEC .)
    PROC            reduce using rule 25 (expr -> VAR DEC .)
    FUNC            reduce using rule 25 (expr -> VAR DEC .)
    $end            reduce using rule 25 (expr -> VAR DEC .)
    )               reduce using rule 25 (expr -> VAR DEC .)
    ,               reduce using rule 25 (expr -> VAR DEC .)
    }               reduce using rule 25 (expr -> VAR DEC .)
    ELSE            reduce using rule 25 (expr -> VAR DEC .)
    ;               reduce using rule 25 (expr -> VAR DEC .)


state 57

    (26) expr -> VAR INC .
    OR              reduce using rule 26 (expr -> VAR INC .)
    AND             reduce using rule 26 (expr -> VAR INC .)
    NE              reduce using rule 26 (expr -> VAR INC .)
    EQ              reduce using rule 26 (expr -> VAR INC .)
    GE              reduce using rule 26 (expr -> VAR INC .)
    GT              reduce using rule 26 (expr -> VAR INC .)
    LE              reduce using rule 26 (expr -> VAR INC .)
    LT              reduce using rule 26 (expr -> VAR INC .)
    ^               reduce using rule 26 (expr -> VAR INC .)
    %               reduce using rule 26 (expr -> VAR INC .)
    /               reduce using rule 26 (expr -> VAR INC .)
    *               reduce using rule 26 (expr -> VAR INC .)
    -               reduce using rule 26 (expr -> VAR INC .)
    +               reduce using rule 26 (expr -> VAR INC .)
    {               reduce using rule 26 (expr -> VAR INC .)
    IF              reduce using rule 26 (expr -> VAR INC .)
    FOR             reduce using rule 26 (expr -> VAR INC .)
    WHILE           reduce using rule 26 (expr -> VAR INC .)
    PRINT           reduce using rule 26 (expr -> VAR INC .)
    PROCEDURE       reduce using rule 26 (expr -> VAR INC .)
    RETURN          reduce using rule 26 (expr -> VAR INC .)
    VAR             reduce using rule 26 (expr -> VAR INC .)
    DEC             reduce using rule 26 (expr -> VAR INC .)
    INC             reduce using rule 26 (expr -> VAR INC .)
    NOT             reduce using rule 26 (expr -> VAR INC .)
    (               reduce using rule 26 (expr -> VAR INC .)
    BLTIN           reduce using rule 26 (expr -> VAR INC .)
    READ            reduce using rule 26 (expr -> VAR INC .)
    FUNCTION        reduce using rule 26 (expr -> VAR INC .)
    NUMBER          reduce using rule 26 (expr -> VAR INC .)
    PROC            reduce using rule 26 (expr -> VAR INC .)
    FUNC            reduce using rule 26 (expr -> VAR INC .)
    $end            reduce using rule 26 (expr -> VAR INC .)
    )               reduce using rule 26 (expr -> VAR INC .)
    ,               reduce using rule 26 (expr -> VAR INC .)
    }               reduce using rule 26 (expr -> VAR INC .)
    ELSE            reduce using rule 26 (expr -> VAR INC .)
    ;               reduce using rule 26 (expr -> VAR INC .)


state 58

    (6) asgn -> VAR MODEQ . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 101

state 59

    (7) asgn -> VAR DIVEQ . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 102

state 60

    (8) asgn -> VAR MULEQ . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 103

state 61

    (9) asgn -> VAR SUBEQ . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 104

state 62

    (10) asgn -> VAR ADDEQ . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 105

state 63

    (11) asgn -> VAR = . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 106

state 64

    (27) expr -> DEC VAR .
    OR              reduce using rule 27 (expr -> DEC VAR .)
    AND             reduce using rule 27 (expr -> DEC VAR .)
    NE              reduce using rule 27 (expr -> DEC VAR .)
    EQ              reduce using rule 27 (expr -> DEC VAR .)
    GE              reduce using rule 27 (expr -> DEC VAR .)
    GT              reduce using rule 27 (expr -> DEC VAR .)
    LE              reduce using rule 27 (expr -> DEC VAR .)
    LT              reduce using rule 27 (expr -> DEC VAR .)
    ^               reduce using rule 27 (expr -> DEC VAR .)
    %               reduce using rule 27 (expr -> DEC VAR .)
    /               reduce using rule 27 (expr -> DEC VAR .)
    *               reduce using rule 27 (expr -> DEC VAR .)
    -               reduce using rule 27 (expr -> DEC VAR .)
    +               reduce using rule 27 (expr -> DEC VAR .)
    {               reduce using rule 27 (expr -> DEC VAR .)
    IF              reduce using rule 27 (expr -> DEC VAR .)
    FOR             reduce using rule 27 (expr -> DEC VAR .)
    WHILE           reduce using rule 27 (expr -> DEC VAR .)
    PRINT           reduce using rule 27 (expr -> DEC VAR .)
    PROCEDURE       reduce using rule 27 (expr -> DEC VAR .)
    RETURN          reduce using rule 27 (expr -> DEC VAR .)
    VAR             reduce using rule 27 (expr -> DEC VAR .)
    DEC             reduce using rule 27 (expr -> DEC VAR .)
    INC             reduce using rule 27 (expr -> DEC VAR .)
    NOT             reduce using rule 27 (expr -> DEC VAR .)
    (               reduce using rule 27 (expr -> DEC VAR .)
    BLTIN           reduce using rule 27 (expr -> DEC VAR .)
    READ            reduce using rule 27 (expr -> DEC VAR .)
    FUNCTION        reduce using rule 27 (expr -> DEC VAR .)
    NUMBER          reduce using rule 27 (expr -> DEC VAR .)
    PROC            reduce using rule 27 (expr -> DEC VAR .)
    FUNC            reduce using rule 27 (expr -> DEC VAR .)
    $end            reduce using rule 27 (expr -> DEC VAR .)
    )               reduce using rule 27 (expr -> DEC VAR .)
    ,               reduce using rule 27 (expr -> DEC VAR .)
    }               reduce using rule 27 (expr -> DEC VAR .)
    ELSE            reduce using rule 27 (expr -> DEC VAR .)
    ;               reduce using rule 27 (expr -> DEC VAR .)


state 65

    (28) expr -> INC VAR .
    OR              reduce using rule 28 (expr -> INC VAR .)
    AND             reduce using rule 28 (expr -> INC VAR .)
    NE              reduce using rule 28 (expr -> INC VAR .)
    EQ              reduce using rule 28 (expr -> INC VAR .)
    GE              reduce using rule 28 (expr -> INC VAR .)
    GT              reduce using rule 28 (expr -> INC VAR .)
    LE              reduce using rule 28 (expr -> INC VAR .)
    LT              reduce using rule 28 (expr -> INC VAR .)
    ^               reduce using rule 28 (expr -> INC VAR .)
    %               reduce using rule 28 (expr -> INC VAR .)
    /               reduce using rule 28 (expr -> INC VAR .)
    *               reduce using rule 28 (expr -> INC VAR .)
    -               reduce using rule 28 (expr -> INC VAR .)
    +               reduce using rule 28 (expr -> INC VAR .)
    {               reduce using rule 28 (expr -> INC VAR .)
    IF              reduce using rule 28 (expr -> INC VAR .)
    FOR             reduce using rule 28 (expr -> INC VAR .)
    WHILE           reduce using rule 28 (expr -> INC VAR .)
    PRINT           reduce using rule 28 (expr -> INC VAR .)
    PROCEDURE       reduce using rule 28 (expr -> INC VAR .)
    RETURN          reduce using rule 28 (expr -> INC VAR .)
    VAR             reduce using rule 28 (expr -> INC VAR .)
    DEC             reduce using rule 28 (expr -> INC VAR .)
    INC             reduce using rule 28 (expr -> INC VAR .)
    NOT             reduce using rule 28 (expr -> INC VAR .)
    (               reduce using rule 28 (expr -> INC VAR .)
    BLTIN           reduce using rule 28 (expr -> INC VAR .)
    READ            reduce using rule 28 (expr -> INC VAR .)
    FUNCTION        reduce using rule 28 (expr -> INC VAR .)
    NUMBER          reduce using rule 28 (expr -> INC VAR .)
    PROC            reduce using rule 28 (expr -> INC VAR .)
    FUNC            reduce using rule 28 (expr -> INC VAR .)
    $end            reduce using rule 28 (expr -> INC VAR .)
    )               reduce using rule 28 (expr -> INC VAR .)
    ,               reduce using rule 28 (expr -> INC VAR .)
    }               reduce using rule 28 (expr -> INC VAR .)
    ELSE            reduce using rule 28 (expr -> INC VAR .)
    ;               reduce using rule 28 (expr -> INC VAR .)


state 66

    (29) expr -> NOT expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    OR              reduce using rule 29 (expr -> NOT expr .)
    AND             reduce using rule 29 (expr -> NOT expr .)
    NE              reduce using rule 29 (expr -> NOT expr .)
    EQ              reduce using rule 29 (expr -> NOT expr .)
    GE              reduce using rule 29 (expr -> NOT expr .)
    GT              reduce using rule 29 (expr -> NOT expr .)
    LE              reduce using rule 29 (expr -> NOT expr .)
    LT              reduce using rule 29 (expr -> NOT expr .)
    %               reduce using rule 29 (expr -> NOT expr .)
    /               reduce using rule 29 (expr -> NOT expr .)
    *               reduce using rule 29 (expr -> NOT expr .)
    -               reduce using rule 29 (expr -> NOT expr .)
    +               reduce using rule 29 (expr -> NOT expr .)
    {               reduce using rule 29 (expr -> NOT expr .)
    IF              reduce using rule 29 (expr -> NOT expr .)
    FOR             reduce using rule 29 (expr -> NOT expr .)
    WHILE           reduce using rule 29 (expr -> NOT expr .)
    PRINT           reduce using rule 29 (expr -> NOT expr .)
    PROCEDURE       reduce using rule 29 (expr -> NOT expr .)
    RETURN          reduce using rule 29 (expr -> NOT expr .)
    VAR             reduce using rule 29 (expr -> NOT expr .)
    DEC             reduce using rule 29 (expr -> NOT expr .)
    INC             reduce using rule 29 (expr -> NOT expr .)
    NOT             reduce using rule 29 (expr -> NOT expr .)
    (               reduce using rule 29 (expr -> NOT expr .)
    BLTIN           reduce using rule 29 (expr -> NOT expr .)
    READ            reduce using rule 29 (expr -> NOT expr .)
    FUNCTION        reduce using rule 29 (expr -> NOT expr .)
    NUMBER          reduce using rule 29 (expr -> NOT expr .)
    PROC            reduce using rule 29 (expr -> NOT expr .)
    FUNC            reduce using rule 29 (expr -> NOT expr .)
    $end            reduce using rule 29 (expr -> NOT expr .)
    )               reduce using rule 29 (expr -> NOT expr .)
    ,               reduce using rule 29 (expr -> NOT expr .)
    }               reduce using rule 29 (expr -> NOT expr .)
    ELSE            reduce using rule 29 (expr -> NOT expr .)
    ;               reduce using rule 29 (expr -> NOT expr .)
    ^               shift and go to state 39


state 67

    (30) expr -> - expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    OR              reduce using rule 30 (expr -> - expr .)
    AND             reduce using rule 30 (expr -> - expr .)
    NE              reduce using rule 30 (expr -> - expr .)
    EQ              reduce using rule 30 (expr -> - expr .)
    GE              reduce using rule 30 (expr -> - expr .)
    GT              reduce using rule 30 (expr -> - expr .)
    LE              reduce using rule 30 (expr -> - expr .)
    LT              reduce using rule 30 (expr -> - expr .)
    %               reduce using rule 30 (expr -> - expr .)
    /               reduce using rule 30 (expr -> - expr .)
    *               reduce using rule 30 (expr -> - expr .)
    -               reduce using rule 30 (expr -> - expr .)
    +               reduce using rule 30 (expr -> - expr .)
    {               reduce using rule 30 (expr -> - expr .)
    IF              reduce using rule 30 (expr -> - expr .)
    FOR             reduce using rule 30 (expr -> - expr .)
    WHILE           reduce using rule 30 (expr -> - expr .)
    PRINT           reduce using rule 30 (expr -> - expr .)
    PROCEDURE       reduce using rule 30 (expr -> - expr .)
    RETURN          reduce using rule 30 (expr -> - expr .)
    VAR             reduce using rule 30 (expr -> - expr .)
    DEC             reduce using rule 30 (expr -> - expr .)
    INC             reduce using rule 30 (expr -> - expr .)
    NOT             reduce using rule 30 (expr -> - expr .)
    (               reduce using rule 30 (expr -> - expr .)
    BLTIN           reduce using rule 30 (expr -> - expr .)
    READ            reduce using rule 30 (expr -> - expr .)
    FUNCTION        reduce using rule 30 (expr -> - expr .)
    NUMBER          reduce using rule 30 (expr -> - expr .)
    PROC            reduce using rule 30 (expr -> - expr .)
    FUNC            reduce using rule 30 (expr -> - expr .)
    $end            reduce using rule 30 (expr -> - expr .)
    )               reduce using rule 30 (expr -> - expr .)
    ,               reduce using rule 30 (expr -> - expr .)
    }               reduce using rule 30 (expr -> - expr .)
    ELSE            reduce using rule 30 (expr -> - expr .)
    ;               reduce using rule 30 (expr -> - expr .)
    ^               shift and go to state 39


state 68

    (46) expr -> BLTIN ( . expr )
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 107

state 69

    (47) expr -> READ ( . VAR )
    VAR             shift and go to state 108


state 70

    (48) expr -> FUNCTION ( . arglist )
    (61) arglist -> . arglist , expr
    (62) arglist -> . expr
    (63) arglist -> . empty
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    (64) empty -> .
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26
    )               reduce using rule 64 (empty -> .)
    ,               reduce using rule 64 (empty -> .)

    arglist                        shift and go to state 109
    expr                           shift and go to state 98
    empty                          shift and go to state 99

state 71

    (56) func_header -> PROC procname .
    (               reduce using rule 56 (func_header -> PROC procname .)


state 72

    (58) procname -> PROCEDURE .
    (               reduce using rule 58 (procname -> PROCEDURE .)


state 73

    (59) procname -> FUNCTION .
    (               reduce using rule 59 (procname -> FUNCTION .)


state 74

    (60) procname -> VAR .
    (               reduce using rule 60 (procname -> VAR .)


state 75

    (57) func_header -> FUNC procname .
    (               reduce using rule 57 (func_header -> FUNC procname .)


state 76

    (12) stmt -> { stmtlist } .
    {               reduce using rule 12 (stmt -> { stmtlist } .)
    IF              reduce using rule 12 (stmt -> { stmtlist } .)
    FOR             reduce using rule 12 (stmt -> { stmtlist } .)
    WHILE           reduce using rule 12 (stmt -> { stmtlist } .)
    PRINT           reduce using rule 12 (stmt -> { stmtlist } .)
    PROCEDURE       reduce using rule 12 (stmt -> { stmtlist } .)
    RETURN          reduce using rule 12 (stmt -> { stmtlist } .)
    VAR             reduce using rule 12 (stmt -> { stmtlist } .)
    DEC             reduce using rule 12 (stmt -> { stmtlist } .)
    INC             reduce using rule 12 (stmt -> { stmtlist } .)
    NOT             reduce using rule 12 (stmt -> { stmtlist } .)
    -               reduce using rule 12 (stmt -> { stmtlist } .)
    (               reduce using rule 12 (stmt -> { stmtlist } .)
    BLTIN           reduce using rule 12 (stmt -> { stmtlist } .)
    READ            reduce using rule 12 (stmt -> { stmtlist } .)
    FUNCTION        reduce using rule 12 (stmt -> { stmtlist } .)
    NUMBER          reduce using rule 12 (stmt -> { stmtlist } .)
    PROC            reduce using rule 12 (stmt -> { stmtlist } .)
    FUNC            reduce using rule 12 (stmt -> { stmtlist } .)
    $end            reduce using rule 12 (stmt -> { stmtlist } .)
    }               reduce using rule 12 (stmt -> { stmtlist } .)
    ELSE            reduce using rule 12 (stmt -> { stmtlist } .)


state 77

    (23) stmtlist -> stmtlist stmt .
    }               reduce using rule 23 (stmtlist -> stmtlist stmt .)
    {               reduce using rule 23 (stmtlist -> stmtlist stmt .)
    IF              reduce using rule 23 (stmtlist -> stmtlist stmt .)
    FOR             reduce using rule 23 (stmtlist -> stmtlist stmt .)
    WHILE           reduce using rule 23 (stmtlist -> stmtlist stmt .)
    PRINT           reduce using rule 23 (stmtlist -> stmtlist stmt .)
    PROCEDURE       reduce using rule 23 (stmtlist -> stmtlist stmt .)
    RETURN          reduce using rule 23 (stmtlist -> stmtlist stmt .)
    VAR             reduce using rule 23 (stmtlist -> stmtlist stmt .)
    DEC             reduce using rule 23 (stmtlist -> stmtlist stmt .)
    INC             reduce using rule 23 (stmtlist -> stmtlist stmt .)
    NOT             reduce using rule 23 (stmtlist -> stmtlist stmt .)
    -               reduce using rule 23 (stmtlist -> stmtlist stmt .)
    (               reduce using rule 23 (stmtlist -> stmtlist stmt .)
    BLTIN           reduce using rule 23 (stmtlist -> stmtlist stmt .)
    READ            reduce using rule 23 (stmtlist -> stmtlist stmt .)
    FUNCTION        reduce using rule 23 (stmtlist -> stmtlist stmt .)
    NUMBER          reduce using rule 23 (stmtlist -> stmtlist stmt .)


state 78

    (31) expr -> expr OR expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    OR              reduce using rule 31 (expr -> expr OR expr .)
    {               reduce using rule 31 (expr -> expr OR expr .)
    IF              reduce using rule 31 (expr -> expr OR expr .)
    FOR             reduce using rule 31 (expr -> expr OR expr .)
    WHILE           reduce using rule 31 (expr -> expr OR expr .)
    PRINT           reduce using rule 31 (expr -> expr OR expr .)
    PROCEDURE       reduce using rule 31 (expr -> expr OR expr .)
    RETURN          reduce using rule 31 (expr -> expr OR expr .)
    VAR             reduce using rule 31 (expr -> expr OR expr .)
    DEC             reduce using rule 31 (expr -> expr OR expr .)
    INC             reduce using rule 31 (expr -> expr OR expr .)
    NOT             reduce using rule 31 (expr -> expr OR expr .)
    (               reduce using rule 31 (expr -> expr OR expr .)
    BLTIN           reduce using rule 31 (expr -> expr OR expr .)
    READ            reduce using rule 31 (expr -> expr OR expr .)
    FUNCTION        reduce using rule 31 (expr -> expr OR expr .)
    NUMBER          reduce using rule 31 (expr -> expr OR expr .)
    PROC            reduce using rule 31 (expr -> expr OR expr .)
    FUNC            reduce using rule 31 (expr -> expr OR expr .)
    $end            reduce using rule 31 (expr -> expr OR expr .)
    )               reduce using rule 31 (expr -> expr OR expr .)
    ,               reduce using rule 31 (expr -> expr OR expr .)
    }               reduce using rule 31 (expr -> expr OR expr .)
    ELSE            reduce using rule 31 (expr -> expr OR expr .)
    ;               reduce using rule 31 (expr -> expr OR expr .)
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 79

    (32) expr -> expr AND expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    OR              reduce using rule 32 (expr -> expr AND expr .)
    AND             reduce using rule 32 (expr -> expr AND expr .)
    {               reduce using rule 32 (expr -> expr AND expr .)
    IF              reduce using rule 32 (expr -> expr AND expr .)
    FOR             reduce using rule 32 (expr -> expr AND expr .)
    WHILE           reduce using rule 32 (expr -> expr AND expr .)
    PRINT           reduce using rule 32 (expr -> expr AND expr .)
    PROCEDURE       reduce using rule 32 (expr -> expr AND expr .)
    RETURN          reduce using rule 32 (expr -> expr AND expr .)
    VAR             reduce using rule 32 (expr -> expr AND expr .)
    DEC             reduce using rule 32 (expr -> expr AND expr .)
    INC             reduce using rule 32 (expr -> expr AND expr .)
    NOT             reduce using rule 32 (expr -> expr AND expr .)
    (               reduce using rule 32 (expr -> expr AND expr .)
    BLTIN           reduce using rule 32 (expr -> expr AND expr .)
    READ            reduce using rule 32 (expr -> expr AND expr .)
    FUNCTION        reduce using rule 32 (expr -> expr AND expr .)
    NUMBER          reduce using rule 32 (expr -> expr AND expr .)
    PROC            reduce using rule 32 (expr -> expr AND expr .)
    FUNC            reduce using rule 32 (expr -> expr AND expr .)
    $end            reduce using rule 32 (expr -> expr AND expr .)
    )               reduce using rule 32 (expr -> expr AND expr .)
    ,               reduce using rule 32 (expr -> expr AND expr .)
    }               reduce using rule 32 (expr -> expr AND expr .)
    ELSE            reduce using rule 32 (expr -> expr AND expr .)
    ;               reduce using rule 32 (expr -> expr AND expr .)
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 80

    (33) expr -> expr NE expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    OR              reduce using rule 33 (expr -> expr NE expr .)
    AND             reduce using rule 33 (expr -> expr NE expr .)
    NE              reduce using rule 33 (expr -> expr NE expr .)
    EQ              reduce using rule 33 (expr -> expr NE expr .)
    {               reduce using rule 33 (expr -> expr NE expr .)
    IF              reduce using rule 33 (expr -> expr NE expr .)
    FOR             reduce using rule 33 (expr -> expr NE expr .)
    WHILE           reduce using rule 33 (expr -> expr NE expr .)
    PRINT           reduce using rule 33 (expr -> expr NE expr .)
    PROCEDURE       reduce using rule 33 (expr -> expr NE expr .)
    RETURN          reduce using rule 33 (expr -> expr NE expr .)
    VAR             reduce using rule 33 (expr -> expr NE expr .)
    DEC             reduce using rule 33 (expr -> expr NE expr .)
    INC             reduce using rule 33 (expr -> expr NE expr .)
    NOT             reduce using rule 33 (expr -> expr NE expr .)
    (               reduce using rule 33 (expr -> expr NE expr .)
    BLTIN           reduce using rule 33 (expr -> expr NE expr .)
    READ            reduce using rule 33 (expr -> expr NE expr .)
    FUNCTION        reduce using rule 33 (expr -> expr NE expr .)
    NUMBER          reduce using rule 33 (expr -> expr NE expr .)
    PROC            reduce using rule 33 (expr -> expr NE expr .)
    FUNC            reduce using rule 33 (expr -> expr NE expr .)
    $end            reduce using rule 33 (expr -> expr NE expr .)
    )               reduce using rule 33 (expr -> expr NE expr .)
    ,               reduce using rule 33 (expr -> expr NE expr .)
    }               reduce using rule 33 (expr -> expr NE expr .)
    ELSE            reduce using rule 33 (expr -> expr NE expr .)
    ;               reduce using rule 33 (expr -> expr NE expr .)
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 81

    (34) expr -> expr EQ expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    OR              reduce using rule 34 (expr -> expr EQ expr .)
    AND             reduce using rule 34 (expr -> expr EQ expr .)
    NE              reduce using rule 34 (expr -> expr EQ expr .)
    EQ              reduce using rule 34 (expr -> expr EQ expr .)
    {               reduce using rule 34 (expr -> expr EQ expr .)
    IF              reduce using rule 34 (expr -> expr EQ expr .)
    FOR             reduce using rule 34 (expr -> expr EQ expr .)
    WHILE           reduce using rule 34 (expr -> expr EQ expr .)
    PRINT           reduce using rule 34 (expr -> expr EQ expr .)
    PROCEDURE       reduce using rule 34 (expr -> expr EQ expr .)
    RETURN          reduce using rule 34 (expr -> expr EQ expr .)
    VAR             reduce using rule 34 (expr -> expr EQ expr .)
    DEC             reduce using rule 34 (expr -> expr EQ expr .)
    INC             reduce using rule 34 (expr -> expr EQ expr .)
    NOT             reduce using rule 34 (expr -> expr EQ expr .)
    (               reduce using rule 34 (expr -> expr EQ expr .)
    BLTIN           reduce using rule 34 (expr -> expr EQ expr .)
    READ            reduce using rule 34 (expr -> expr EQ expr .)
    FUNCTION        reduce using rule 34 (expr -> expr EQ expr .)
    NUMBER          reduce using rule 34 (expr -> expr EQ expr .)
    PROC            reduce using rule 34 (expr -> expr EQ expr .)
    FUNC            reduce using rule 34 (expr -> expr EQ expr .)
    $end            reduce using rule 34 (expr -> expr EQ expr .)
    )               reduce using rule 34 (expr -> expr EQ expr .)
    ,               reduce using rule 34 (expr -> expr EQ expr .)
    }               reduce using rule 34 (expr -> expr EQ expr .)
    ELSE            reduce using rule 34 (expr -> expr EQ expr .)
    ;               reduce using rule 34 (expr -> expr EQ expr .)
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 82

    (35) expr -> expr GE expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    OR              reduce using rule 35 (expr -> expr GE expr .)
    AND             reduce using rule 35 (expr -> expr GE expr .)
    NE              reduce using rule 35 (expr -> expr GE expr .)
    EQ              reduce using rule 35 (expr -> expr GE expr .)
    GE              reduce using rule 35 (expr -> expr GE expr .)
    GT              reduce using rule 35 (expr -> expr GE expr .)
    LE              reduce using rule 35 (expr -> expr GE expr .)
    LT              reduce using rule 35 (expr -> expr GE expr .)
    {               reduce using rule 35 (expr -> expr GE expr .)
    IF              reduce using rule 35 (expr -> expr GE expr .)
    FOR             reduce using rule 35 (expr -> expr GE expr .)
    WHILE           reduce using rule 35 (expr -> expr GE expr .)
    PRINT           reduce using rule 35 (expr -> expr GE expr .)
    PROCEDURE       reduce using rule 35 (expr -> expr GE expr .)
    RETURN          reduce using rule 35 (expr -> expr GE expr .)
    VAR             reduce using rule 35 (expr -> expr GE expr .)
    DEC             reduce using rule 35 (expr -> expr GE expr .)
    INC             reduce using rule 35 (expr -> expr GE expr .)
    NOT             reduce using rule 35 (expr -> expr GE expr .)
    (               reduce using rule 35 (expr -> expr GE expr .)
    BLTIN           reduce using rule 35 (expr -> expr GE expr .)
    READ            reduce using rule 35 (expr -> expr GE expr .)
    FUNCTION        reduce using rule 35 (expr -> expr GE expr .)
    NUMBER          reduce using rule 35 (expr -> expr GE expr .)
    PROC            reduce using rule 35 (expr -> expr GE expr .)
    FUNC            reduce using rule 35 (expr -> expr GE expr .)
    $end            reduce using rule 35 (expr -> expr GE expr .)
    )               reduce using rule 35 (expr -> expr GE expr .)
    ,               reduce using rule 35 (expr -> expr GE expr .)
    }               reduce using rule 35 (expr -> expr GE expr .)
    ELSE            reduce using rule 35 (expr -> expr GE expr .)
    ;               reduce using rule 35 (expr -> expr GE expr .)
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 83

    (36) expr -> expr GT expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    OR              reduce using rule 36 (expr -> expr GT expr .)
    AND             reduce using rule 36 (expr -> expr GT expr .)
    NE              reduce using rule 36 (expr -> expr GT expr .)
    EQ              reduce using rule 36 (expr -> expr GT expr .)
    GE              reduce using rule 36 (expr -> expr GT expr .)
    GT              reduce using rule 36 (expr -> expr GT expr .)
    LE              reduce using rule 36 (expr -> expr GT expr .)
    LT              reduce using rule 36 (expr -> expr GT expr .)
    {               reduce using rule 36 (expr -> expr GT expr .)
    IF              reduce using rule 36 (expr -> expr GT expr .)
    FOR             reduce using rule 36 (expr -> expr GT expr .)
    WHILE           reduce using rule 36 (expr -> expr GT expr .)
    PRINT           reduce using rule 36 (expr -> expr GT expr .)
    PROCEDURE       reduce using rule 36 (expr -> expr GT expr .)
    RETURN          reduce using rule 36 (expr -> expr GT expr .)
    VAR             reduce using rule 36 (expr -> expr GT expr .)
    DEC             reduce using rule 36 (expr -> expr GT expr .)
    INC             reduce using rule 36 (expr -> expr GT expr .)
    NOT             reduce using rule 36 (expr -> expr GT expr .)
    (               reduce using rule 36 (expr -> expr GT expr .)
    BLTIN           reduce using rule 36 (expr -> expr GT expr .)
    READ            reduce using rule 36 (expr -> expr GT expr .)
    FUNCTION        reduce using rule 36 (expr -> expr GT expr .)
    NUMBER          reduce using rule 36 (expr -> expr GT expr .)
    PROC            reduce using rule 36 (expr -> expr GT expr .)
    FUNC            reduce using rule 36 (expr -> expr GT expr .)
    $end            reduce using rule 36 (expr -> expr GT expr .)
    )               reduce using rule 36 (expr -> expr GT expr .)
    ,               reduce using rule 36 (expr -> expr GT expr .)
    }               reduce using rule 36 (expr -> expr GT expr .)
    ELSE            reduce using rule 36 (expr -> expr GT expr .)
    ;               reduce using rule 36 (expr -> expr GT expr .)
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 84

    (37) expr -> expr LE expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    OR              reduce using rule 37 (expr -> expr LE expr .)
    AND             reduce using rule 37 (expr -> expr LE expr .)
    NE              reduce using rule 37 (expr -> expr LE expr .)
    EQ              reduce using rule 37 (expr -> expr LE expr .)
    GE              reduce using rule 37 (expr -> expr LE expr .)
    GT              reduce using rule 37 (expr -> expr LE expr .)
    LE              reduce using rule 37 (expr -> expr LE expr .)
    LT              reduce using rule 37 (expr -> expr LE expr .)
    {               reduce using rule 37 (expr -> expr LE expr .)
    IF              reduce using rule 37 (expr -> expr LE expr .)
    FOR             reduce using rule 37 (expr -> expr LE expr .)
    WHILE           reduce using rule 37 (expr -> expr LE expr .)
    PRINT           reduce using rule 37 (expr -> expr LE expr .)
    PROCEDURE       reduce using rule 37 (expr -> expr LE expr .)
    RETURN          reduce using rule 37 (expr -> expr LE expr .)
    VAR             reduce using rule 37 (expr -> expr LE expr .)
    DEC             reduce using rule 37 (expr -> expr LE expr .)
    INC             reduce using rule 37 (expr -> expr LE expr .)
    NOT             reduce using rule 37 (expr -> expr LE expr .)
    (               reduce using rule 37 (expr -> expr LE expr .)
    BLTIN           reduce using rule 37 (expr -> expr LE expr .)
    READ            reduce using rule 37 (expr -> expr LE expr .)
    FUNCTION        reduce using rule 37 (expr -> expr LE expr .)
    NUMBER          reduce using rule 37 (expr -> expr LE expr .)
    PROC            reduce using rule 37 (expr -> expr LE expr .)
    FUNC            reduce using rule 37 (expr -> expr LE expr .)
    $end            reduce using rule 37 (expr -> expr LE expr .)
    )               reduce using rule 37 (expr -> expr LE expr .)
    ,               reduce using rule 37 (expr -> expr LE expr .)
    }               reduce using rule 37 (expr -> expr LE expr .)
    ELSE            reduce using rule 37 (expr -> expr LE expr .)
    ;               reduce using rule 37 (expr -> expr LE expr .)
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 85

    (38) expr -> expr LT expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    OR              reduce using rule 38 (expr -> expr LT expr .)
    AND             reduce using rule 38 (expr -> expr LT expr .)
    NE              reduce using rule 38 (expr -> expr LT expr .)
    EQ              reduce using rule 38 (expr -> expr LT expr .)
    GE              reduce using rule 38 (expr -> expr LT expr .)
    GT              reduce using rule 38 (expr -> expr LT expr .)
    LE              reduce using rule 38 (expr -> expr LT expr .)
    LT              reduce using rule 38 (expr -> expr LT expr .)
    {               reduce using rule 38 (expr -> expr LT expr .)
    IF              reduce using rule 38 (expr -> expr LT expr .)
    FOR             reduce using rule 38 (expr -> expr LT expr .)
    WHILE           reduce using rule 38 (expr -> expr LT expr .)
    PRINT           reduce using rule 38 (expr -> expr LT expr .)
    PROCEDURE       reduce using rule 38 (expr -> expr LT expr .)
    RETURN          reduce using rule 38 (expr -> expr LT expr .)
    VAR             reduce using rule 38 (expr -> expr LT expr .)
    DEC             reduce using rule 38 (expr -> expr LT expr .)
    INC             reduce using rule 38 (expr -> expr LT expr .)
    NOT             reduce using rule 38 (expr -> expr LT expr .)
    (               reduce using rule 38 (expr -> expr LT expr .)
    BLTIN           reduce using rule 38 (expr -> expr LT expr .)
    READ            reduce using rule 38 (expr -> expr LT expr .)
    FUNCTION        reduce using rule 38 (expr -> expr LT expr .)
    NUMBER          reduce using rule 38 (expr -> expr LT expr .)
    PROC            reduce using rule 38 (expr -> expr LT expr .)
    FUNC            reduce using rule 38 (expr -> expr LT expr .)
    $end            reduce using rule 38 (expr -> expr LT expr .)
    )               reduce using rule 38 (expr -> expr LT expr .)
    ,               reduce using rule 38 (expr -> expr LT expr .)
    }               reduce using rule 38 (expr -> expr LT expr .)
    ELSE            reduce using rule 38 (expr -> expr LT expr .)
    ;               reduce using rule 38 (expr -> expr LT expr .)
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 86

    (39) expr -> expr ^ expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    OR              reduce using rule 39 (expr -> expr ^ expr .)
    AND             reduce using rule 39 (expr -> expr ^ expr .)
    NE              reduce using rule 39 (expr -> expr ^ expr .)
    EQ              reduce using rule 39 (expr -> expr ^ expr .)
    GE              reduce using rule 39 (expr -> expr ^ expr .)
    GT              reduce using rule 39 (expr -> expr ^ expr .)
    LE              reduce using rule 39 (expr -> expr ^ expr .)
    LT              reduce using rule 39 (expr -> expr ^ expr .)
    %               reduce using rule 39 (expr -> expr ^ expr .)
    /               reduce using rule 39 (expr -> expr ^ expr .)
    *               reduce using rule 39 (expr -> expr ^ expr .)
    -               reduce using rule 39 (expr -> expr ^ expr .)
    +               reduce using rule 39 (expr -> expr ^ expr .)
    {               reduce using rule 39 (expr -> expr ^ expr .)
    IF              reduce using rule 39 (expr -> expr ^ expr .)
    FOR             reduce using rule 39 (expr -> expr ^ expr .)
    WHILE           reduce using rule 39 (expr -> expr ^ expr .)
    PRINT           reduce using rule 39 (expr -> expr ^ expr .)
    PROCEDURE       reduce using rule 39 (expr -> expr ^ expr .)
    RETURN          reduce using rule 39 (expr -> expr ^ expr .)
    VAR             reduce using rule 39 (expr -> expr ^ expr .)
    DEC             reduce using rule 39 (expr -> expr ^ expr .)
    INC             reduce using rule 39 (expr -> expr ^ expr .)
    NOT             reduce using rule 39 (expr -> expr ^ expr .)
    (               reduce using rule 39 (expr -> expr ^ expr .)
    BLTIN           reduce using rule 39 (expr -> expr ^ expr .)
    READ            reduce using rule 39 (expr -> expr ^ expr .)
    FUNCTION        reduce using rule 39 (expr -> expr ^ expr .)
    NUMBER          reduce using rule 39 (expr -> expr ^ expr .)
    PROC            reduce using rule 39 (expr -> expr ^ expr .)
    FUNC            reduce using rule 39 (expr -> expr ^ expr .)
    $end            reduce using rule 39 (expr -> expr ^ expr .)
    )               reduce using rule 39 (expr -> expr ^ expr .)
    ,               reduce using rule 39 (expr -> expr ^ expr .)
    }               reduce using rule 39 (expr -> expr ^ expr .)
    ELSE            reduce using rule 39 (expr -> expr ^ expr .)
    ;               reduce using rule 39 (expr -> expr ^ expr .)
    ^               shift and go to state 39


state 87

    (40) expr -> expr % expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    OR              reduce using rule 40 (expr -> expr % expr .)
    AND             reduce using rule 40 (expr -> expr % expr .)
    NE              reduce using rule 40 (expr -> expr % expr .)
    EQ              reduce using rule 40 (expr -> expr % expr .)
    GE              reduce using rule 40 (expr -> expr % expr .)
    GT              reduce using rule 40 (expr -> expr % expr .)
    LE              reduce using rule 40 (expr -> expr % expr .)
    LT              reduce using rule 40 (expr -> expr % expr .)
    %               reduce using rule 40 (expr -> expr % expr .)
    /               reduce using rule 40 (expr -> expr % expr .)
    *               reduce using rule 40 (expr -> expr % expr .)
    -               reduce using rule 40 (expr -> expr % expr .)
    +               reduce using rule 40 (expr -> expr % expr .)
    {               reduce using rule 40 (expr -> expr % expr .)
    IF              reduce using rule 40 (expr -> expr % expr .)
    FOR             reduce using rule 40 (expr -> expr % expr .)
    WHILE           reduce using rule 40 (expr -> expr % expr .)
    PRINT           reduce using rule 40 (expr -> expr % expr .)
    PROCEDURE       reduce using rule 40 (expr -> expr % expr .)
    RETURN          reduce using rule 40 (expr -> expr % expr .)
    VAR             reduce using rule 40 (expr -> expr % expr .)
    DEC             reduce using rule 40 (expr -> expr % expr .)
    INC             reduce using rule 40 (expr -> expr % expr .)
    NOT             reduce using rule 40 (expr -> expr % expr .)
    (               reduce using rule 40 (expr -> expr % expr .)
    BLTIN           reduce using rule 40 (expr -> expr % expr .)
    READ            reduce using rule 40 (expr -> expr % expr .)
    FUNCTION        reduce using rule 40 (expr -> expr % expr .)
    NUMBER          reduce using rule 40 (expr -> expr % expr .)
    PROC            reduce using rule 40 (expr -> expr % expr .)
    FUNC            reduce using rule 40 (expr -> expr % expr .)
    $end            reduce using rule 40 (expr -> expr % expr .)
    )               reduce using rule 40 (expr -> expr % expr .)
    ,               reduce using rule 40 (expr -> expr % expr .)
    }               reduce using rule 40 (expr -> expr % expr .)
    ELSE            reduce using rule 40 (expr -> expr % expr .)
    ;               reduce using rule 40 (expr -> expr % expr .)
    ^               shift and go to state 39


state 88

    (41) expr -> expr / expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    OR              reduce using rule 41 (expr -> expr / expr .)
    AND             reduce using rule 41 (expr -> expr / expr .)
    NE              reduce using rule 41 (expr -> expr / expr .)
    EQ              reduce using rule 41 (expr -> expr / expr .)
    GE              reduce using rule 41 (expr -> expr / expr .)
    GT              reduce using rule 41 (expr -> expr / expr .)
    LE              reduce using rule 41 (expr -> expr / expr .)
    LT              reduce using rule 41 (expr -> expr / expr .)
    %               reduce using rule 41 (expr -> expr / expr .)
    /               reduce using rule 41 (expr -> expr / expr .)
    *               reduce using rule 41 (expr -> expr / expr .)
    -               reduce using rule 41 (expr -> expr / expr .)
    +               reduce using rule 41 (expr -> expr / expr .)
    {               reduce using rule 41 (expr -> expr / expr .)
    IF              reduce using rule 41 (expr -> expr / expr .)
    FOR             reduce using rule 41 (expr -> expr / expr .)
    WHILE           reduce using rule 41 (expr -> expr / expr .)
    PRINT           reduce using rule 41 (expr -> expr / expr .)
    PROCEDURE       reduce using rule 41 (expr -> expr / expr .)
    RETURN          reduce using rule 41 (expr -> expr / expr .)
    VAR             reduce using rule 41 (expr -> expr / expr .)
    DEC             reduce using rule 41 (expr -> expr / expr .)
    INC             reduce using rule 41 (expr -> expr / expr .)
    NOT             reduce using rule 41 (expr -> expr / expr .)
    (               reduce using rule 41 (expr -> expr / expr .)
    BLTIN           reduce using rule 41 (expr -> expr / expr .)
    READ            reduce using rule 41 (expr -> expr / expr .)
    FUNCTION        reduce using rule 41 (expr -> expr / expr .)
    NUMBER          reduce using rule 41 (expr -> expr / expr .)
    PROC            reduce using rule 41 (expr -> expr / expr .)
    FUNC            reduce using rule 41 (expr -> expr / expr .)
    $end            reduce using rule 41 (expr -> expr / expr .)
    )               reduce using rule 41 (expr -> expr / expr .)
    ,               reduce using rule 41 (expr -> expr / expr .)
    }               reduce using rule 41 (expr -> expr / expr .)
    ELSE            reduce using rule 41 (expr -> expr / expr .)
    ;               reduce using rule 41 (expr -> expr / expr .)
    ^               shift and go to state 39


state 89

    (42) expr -> expr * expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    OR              reduce using rule 42 (expr -> expr * expr .)
    AND             reduce using rule 42 (expr -> expr * expr .)
    NE              reduce using rule 42 (expr -> expr * expr .)
    EQ              reduce using rule 42 (expr -> expr * expr .)
    GE              reduce using rule 42 (expr -> expr * expr .)
    GT              reduce using rule 42 (expr -> expr * expr .)
    LE              reduce using rule 42 (expr -> expr * expr .)
    LT              reduce using rule 42 (expr -> expr * expr .)
    %               reduce using rule 42 (expr -> expr * expr .)
    /               reduce using rule 42 (expr -> expr * expr .)
    *               reduce using rule 42 (expr -> expr * expr .)
    -               reduce using rule 42 (expr -> expr * expr .)
    +               reduce using rule 42 (expr -> expr * expr .)
    {               reduce using rule 42 (expr -> expr * expr .)
    IF              reduce using rule 42 (expr -> expr * expr .)
    FOR             reduce using rule 42 (expr -> expr * expr .)
    WHILE           reduce using rule 42 (expr -> expr * expr .)
    PRINT           reduce using rule 42 (expr -> expr * expr .)
    PROCEDURE       reduce using rule 42 (expr -> expr * expr .)
    RETURN          reduce using rule 42 (expr -> expr * expr .)
    VAR             reduce using rule 42 (expr -> expr * expr .)
    DEC             reduce using rule 42 (expr -> expr * expr .)
    INC             reduce using rule 42 (expr -> expr * expr .)
    NOT             reduce using rule 42 (expr -> expr * expr .)
    (               reduce using rule 42 (expr -> expr * expr .)
    BLTIN           reduce using rule 42 (expr -> expr * expr .)
    READ            reduce using rule 42 (expr -> expr * expr .)
    FUNCTION        reduce using rule 42 (expr -> expr * expr .)
    NUMBER          reduce using rule 42 (expr -> expr * expr .)
    PROC            reduce using rule 42 (expr -> expr * expr .)
    FUNC            reduce using rule 42 (expr -> expr * expr .)
    $end            reduce using rule 42 (expr -> expr * expr .)
    )               reduce using rule 42 (expr -> expr * expr .)
    ,               reduce using rule 42 (expr -> expr * expr .)
    }               reduce using rule 42 (expr -> expr * expr .)
    ELSE            reduce using rule 42 (expr -> expr * expr .)
    ;               reduce using rule 42 (expr -> expr * expr .)
    ^               shift and go to state 39


state 90

    (43) expr -> expr - expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    OR              reduce using rule 43 (expr -> expr - expr .)
    AND             reduce using rule 43 (expr -> expr - expr .)
    NE              reduce using rule 43 (expr -> expr - expr .)
    EQ              reduce using rule 43 (expr -> expr - expr .)
    GE              reduce using rule 43 (expr -> expr - expr .)
    GT              reduce using rule 43 (expr -> expr - expr .)
    LE              reduce using rule 43 (expr -> expr - expr .)
    LT              reduce using rule 43 (expr -> expr - expr .)
    -               reduce using rule 43 (expr -> expr - expr .)
    +               reduce using rule 43 (expr -> expr - expr .)
    {               reduce using rule 43 (expr -> expr - expr .)
    IF              reduce using rule 43 (expr -> expr - expr .)
    FOR             reduce using rule 43 (expr -> expr - expr .)
    WHILE           reduce using rule 43 (expr -> expr - expr .)
    PRINT           reduce using rule 43 (expr -> expr - expr .)
    PROCEDURE       reduce using rule 43 (expr -> expr - expr .)
    RETURN          reduce using rule 43 (expr -> expr - expr .)
    VAR             reduce using rule 43 (expr -> expr - expr .)
    DEC             reduce using rule 43 (expr -> expr - expr .)
    INC             reduce using rule 43 (expr -> expr - expr .)
    NOT             reduce using rule 43 (expr -> expr - expr .)
    (               reduce using rule 43 (expr -> expr - expr .)
    BLTIN           reduce using rule 43 (expr -> expr - expr .)
    READ            reduce using rule 43 (expr -> expr - expr .)
    FUNCTION        reduce using rule 43 (expr -> expr - expr .)
    NUMBER          reduce using rule 43 (expr -> expr - expr .)
    PROC            reduce using rule 43 (expr -> expr - expr .)
    FUNC            reduce using rule 43 (expr -> expr - expr .)
    $end            reduce using rule 43 (expr -> expr - expr .)
    )               reduce using rule 43 (expr -> expr - expr .)
    ,               reduce using rule 43 (expr -> expr - expr .)
    }               reduce using rule 43 (expr -> expr - expr .)
    ELSE            reduce using rule 43 (expr -> expr - expr .)
    ;               reduce using rule 43 (expr -> expr - expr .)
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42


state 91

    (44) expr -> expr + expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    OR              reduce using rule 44 (expr -> expr + expr .)
    AND             reduce using rule 44 (expr -> expr + expr .)
    NE              reduce using rule 44 (expr -> expr + expr .)
    EQ              reduce using rule 44 (expr -> expr + expr .)
    GE              reduce using rule 44 (expr -> expr + expr .)
    GT              reduce using rule 44 (expr -> expr + expr .)
    LE              reduce using rule 44 (expr -> expr + expr .)
    LT              reduce using rule 44 (expr -> expr + expr .)
    -               reduce using rule 44 (expr -> expr + expr .)
    +               reduce using rule 44 (expr -> expr + expr .)
    {               reduce using rule 44 (expr -> expr + expr .)
    IF              reduce using rule 44 (expr -> expr + expr .)
    FOR             reduce using rule 44 (expr -> expr + expr .)
    WHILE           reduce using rule 44 (expr -> expr + expr .)
    PRINT           reduce using rule 44 (expr -> expr + expr .)
    PROCEDURE       reduce using rule 44 (expr -> expr + expr .)
    RETURN          reduce using rule 44 (expr -> expr + expr .)
    VAR             reduce using rule 44 (expr -> expr + expr .)
    DEC             reduce using rule 44 (expr -> expr + expr .)
    INC             reduce using rule 44 (expr -> expr + expr .)
    NOT             reduce using rule 44 (expr -> expr + expr .)
    (               reduce using rule 44 (expr -> expr + expr .)
    BLTIN           reduce using rule 44 (expr -> expr + expr .)
    READ            reduce using rule 44 (expr -> expr + expr .)
    FUNCTION        reduce using rule 44 (expr -> expr + expr .)
    NUMBER          reduce using rule 44 (expr -> expr + expr .)
    PROC            reduce using rule 44 (expr -> expr + expr .)
    FUNC            reduce using rule 44 (expr -> expr + expr .)
    $end            reduce using rule 44 (expr -> expr + expr .)
    )               reduce using rule 44 (expr -> expr + expr .)
    ,               reduce using rule 44 (expr -> expr + expr .)
    }               reduce using rule 44 (expr -> expr + expr .)
    ELSE            reduce using rule 44 (expr -> expr + expr .)
    ;               reduce using rule 44 (expr -> expr + expr .)
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42


state 92

    (15) stmt -> IF ( expr . ) stmt
    (16) stmt -> IF ( expr . ) stmt ELSE stmt
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    )               shift and go to state 110
    OR              shift and go to state 31
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 93

    (45) expr -> ( expr ) .
    OR              reduce using rule 45 (expr -> ( expr ) .)
    AND             reduce using rule 45 (expr -> ( expr ) .)
    NE              reduce using rule 45 (expr -> ( expr ) .)
    EQ              reduce using rule 45 (expr -> ( expr ) .)
    GE              reduce using rule 45 (expr -> ( expr ) .)
    GT              reduce using rule 45 (expr -> ( expr ) .)
    LE              reduce using rule 45 (expr -> ( expr ) .)
    LT              reduce using rule 45 (expr -> ( expr ) .)
    ^               reduce using rule 45 (expr -> ( expr ) .)
    %               reduce using rule 45 (expr -> ( expr ) .)
    /               reduce using rule 45 (expr -> ( expr ) .)
    *               reduce using rule 45 (expr -> ( expr ) .)
    -               reduce using rule 45 (expr -> ( expr ) .)
    +               reduce using rule 45 (expr -> ( expr ) .)
    {               reduce using rule 45 (expr -> ( expr ) .)
    IF              reduce using rule 45 (expr -> ( expr ) .)
    FOR             reduce using rule 45 (expr -> ( expr ) .)
    WHILE           reduce using rule 45 (expr -> ( expr ) .)
    PRINT           reduce using rule 45 (expr -> ( expr ) .)
    PROCEDURE       reduce using rule 45 (expr -> ( expr ) .)
    RETURN          reduce using rule 45 (expr -> ( expr ) .)
    VAR             reduce using rule 45 (expr -> ( expr ) .)
    DEC             reduce using rule 45 (expr -> ( expr ) .)
    INC             reduce using rule 45 (expr -> ( expr ) .)
    NOT             reduce using rule 45 (expr -> ( expr ) .)
    (               reduce using rule 45 (expr -> ( expr ) .)
    BLTIN           reduce using rule 45 (expr -> ( expr ) .)
    READ            reduce using rule 45 (expr -> ( expr ) .)
    FUNCTION        reduce using rule 45 (expr -> ( expr ) .)
    NUMBER          reduce using rule 45 (expr -> ( expr ) .)
    PROC            reduce using rule 45 (expr -> ( expr ) .)
    FUNC            reduce using rule 45 (expr -> ( expr ) .)
    $end            reduce using rule 45 (expr -> ( expr ) .)
    )               reduce using rule 45 (expr -> ( expr ) .)
    ,               reduce using rule 45 (expr -> ( expr ) .)
    }               reduce using rule 45 (expr -> ( expr ) .)
    ELSE            reduce using rule 45 (expr -> ( expr ) .)
    ;               reduce using rule 45 (expr -> ( expr ) .)


state 94

    (17) stmt -> FOR ( expr . ; expr ; expr ) stmt
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    ;               shift and go to state 111
    OR              shift and go to state 31
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 95

    (18) stmt -> WHILE ( expr . ) stmt
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    )               shift and go to state 112
    OR              shift and go to state 31
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 96

    (51) prlist -> prlist , . STRING
    (52) prlist -> prlist , . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    STRING          shift and go to state 113
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 114

state 97

    (20) stmt -> PROCEDURE ( arglist . )
    (61) arglist -> arglist . , expr
    )               shift and go to state 115
    ,               shift and go to state 116


state 98

    (62) arglist -> expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    )               reduce using rule 62 (arglist -> expr .)
    ,               reduce using rule 62 (arglist -> expr .)
    OR              shift and go to state 31
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 99

    (63) arglist -> empty .
    )               reduce using rule 63 (arglist -> empty .)
    ,               reduce using rule 63 (arglist -> empty .)


state 100

    (55) defn -> func_header ( ) . stmt
    (12) stmt -> . { stmtlist }
    (13) stmt -> . expr
    (14) stmt -> . asgn
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . FOR ( expr ; expr ; expr ) stmt
    (18) stmt -> . WHILE ( expr ) stmt
    (19) stmt -> . PRINT prlist
    (20) stmt -> . PROCEDURE ( arglist )
    (21) stmt -> . RETURN expr
    (22) stmt -> . RETURN
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    (6) asgn -> . VAR MODEQ expr
    (7) asgn -> . VAR DIVEQ expr
    (8) asgn -> . VAR MULEQ expr
    (9) asgn -> . VAR SUBEQ expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR = expr
    {               shift and go to state 7
    IF              shift and go to state 10
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    PRINT           shift and go to state 14
    PROCEDURE       shift and go to state 15
    RETURN          shift and go to state 16
    VAR             shift and go to state 18
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    stmt                           shift and go to state 117
    expr                           shift and go to state 8
    asgn                           shift and go to state 9

state 101

    (6) asgn -> VAR MODEQ expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    {               reduce using rule 6 (asgn -> VAR MODEQ expr .)
    IF              reduce using rule 6 (asgn -> VAR MODEQ expr .)
    FOR             reduce using rule 6 (asgn -> VAR MODEQ expr .)
    WHILE           reduce using rule 6 (asgn -> VAR MODEQ expr .)
    PRINT           reduce using rule 6 (asgn -> VAR MODEQ expr .)
    PROCEDURE       reduce using rule 6 (asgn -> VAR MODEQ expr .)
    RETURN          reduce using rule 6 (asgn -> VAR MODEQ expr .)
    VAR             reduce using rule 6 (asgn -> VAR MODEQ expr .)
    DEC             reduce using rule 6 (asgn -> VAR MODEQ expr .)
    INC             reduce using rule 6 (asgn -> VAR MODEQ expr .)
    NOT             reduce using rule 6 (asgn -> VAR MODEQ expr .)
    (               reduce using rule 6 (asgn -> VAR MODEQ expr .)
    BLTIN           reduce using rule 6 (asgn -> VAR MODEQ expr .)
    READ            reduce using rule 6 (asgn -> VAR MODEQ expr .)
    FUNCTION        reduce using rule 6 (asgn -> VAR MODEQ expr .)
    NUMBER          reduce using rule 6 (asgn -> VAR MODEQ expr .)
    PROC            reduce using rule 6 (asgn -> VAR MODEQ expr .)
    FUNC            reduce using rule 6 (asgn -> VAR MODEQ expr .)
    $end            reduce using rule 6 (asgn -> VAR MODEQ expr .)
    }               reduce using rule 6 (asgn -> VAR MODEQ expr .)
    ELSE            reduce using rule 6 (asgn -> VAR MODEQ expr .)
    OR              shift and go to state 31
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 102

    (7) asgn -> VAR DIVEQ expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    {               reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    IF              reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    FOR             reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    WHILE           reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    PRINT           reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    PROCEDURE       reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    RETURN          reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    VAR             reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    DEC             reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    INC             reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    NOT             reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    (               reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    BLTIN           reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    READ            reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    FUNCTION        reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    NUMBER          reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    PROC            reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    FUNC            reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    $end            reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    }               reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    ELSE            reduce using rule 7 (asgn -> VAR DIVEQ expr .)
    OR              shift and go to state 31
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 103

    (8) asgn -> VAR MULEQ expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    {               reduce using rule 8 (asgn -> VAR MULEQ expr .)
    IF              reduce using rule 8 (asgn -> VAR MULEQ expr .)
    FOR             reduce using rule 8 (asgn -> VAR MULEQ expr .)
    WHILE           reduce using rule 8 (asgn -> VAR MULEQ expr .)
    PRINT           reduce using rule 8 (asgn -> VAR MULEQ expr .)
    PROCEDURE       reduce using rule 8 (asgn -> VAR MULEQ expr .)
    RETURN          reduce using rule 8 (asgn -> VAR MULEQ expr .)
    VAR             reduce using rule 8 (asgn -> VAR MULEQ expr .)
    DEC             reduce using rule 8 (asgn -> VAR MULEQ expr .)
    INC             reduce using rule 8 (asgn -> VAR MULEQ expr .)
    NOT             reduce using rule 8 (asgn -> VAR MULEQ expr .)
    (               reduce using rule 8 (asgn -> VAR MULEQ expr .)
    BLTIN           reduce using rule 8 (asgn -> VAR MULEQ expr .)
    READ            reduce using rule 8 (asgn -> VAR MULEQ expr .)
    FUNCTION        reduce using rule 8 (asgn -> VAR MULEQ expr .)
    NUMBER          reduce using rule 8 (asgn -> VAR MULEQ expr .)
    PROC            reduce using rule 8 (asgn -> VAR MULEQ expr .)
    FUNC            reduce using rule 8 (asgn -> VAR MULEQ expr .)
    $end            reduce using rule 8 (asgn -> VAR MULEQ expr .)
    }               reduce using rule 8 (asgn -> VAR MULEQ expr .)
    ELSE            reduce using rule 8 (asgn -> VAR MULEQ expr .)
    OR              shift and go to state 31
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 104

    (9) asgn -> VAR SUBEQ expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    {               reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    IF              reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    FOR             reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    WHILE           reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    PRINT           reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    PROCEDURE       reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    RETURN          reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    VAR             reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    DEC             reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    INC             reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    NOT             reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    (               reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    BLTIN           reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    READ            reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    FUNCTION        reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    NUMBER          reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    PROC            reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    FUNC            reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    $end            reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    }               reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    ELSE            reduce using rule 9 (asgn -> VAR SUBEQ expr .)
    OR              shift and go to state 31
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 105

    (10) asgn -> VAR ADDEQ expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    {               reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    IF              reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    FOR             reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    WHILE           reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    PRINT           reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    PROCEDURE       reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    RETURN          reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    VAR             reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    DEC             reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    INC             reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    NOT             reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    (               reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    BLTIN           reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    READ            reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    FUNCTION        reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    NUMBER          reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    PROC            reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    FUNC            reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    $end            reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    }               reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    ELSE            reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    OR              shift and go to state 31
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 106

    (11) asgn -> VAR = expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    {               reduce using rule 11 (asgn -> VAR = expr .)
    IF              reduce using rule 11 (asgn -> VAR = expr .)
    FOR             reduce using rule 11 (asgn -> VAR = expr .)
    WHILE           reduce using rule 11 (asgn -> VAR = expr .)
    PRINT           reduce using rule 11 (asgn -> VAR = expr .)
    PROCEDURE       reduce using rule 11 (asgn -> VAR = expr .)
    RETURN          reduce using rule 11 (asgn -> VAR = expr .)
    VAR             reduce using rule 11 (asgn -> VAR = expr .)
    DEC             reduce using rule 11 (asgn -> VAR = expr .)
    INC             reduce using rule 11 (asgn -> VAR = expr .)
    NOT             reduce using rule 11 (asgn -> VAR = expr .)
    (               reduce using rule 11 (asgn -> VAR = expr .)
    BLTIN           reduce using rule 11 (asgn -> VAR = expr .)
    READ            reduce using rule 11 (asgn -> VAR = expr .)
    FUNCTION        reduce using rule 11 (asgn -> VAR = expr .)
    NUMBER          reduce using rule 11 (asgn -> VAR = expr .)
    PROC            reduce using rule 11 (asgn -> VAR = expr .)
    FUNC            reduce using rule 11 (asgn -> VAR = expr .)
    $end            reduce using rule 11 (asgn -> VAR = expr .)
    }               reduce using rule 11 (asgn -> VAR = expr .)
    ELSE            reduce using rule 11 (asgn -> VAR = expr .)
    OR              shift and go to state 31
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 107

    (46) expr -> BLTIN ( expr . )
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    )               shift and go to state 118
    OR              shift and go to state 31
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 108

    (47) expr -> READ ( VAR . )
    )               shift and go to state 119


state 109

    (48) expr -> FUNCTION ( arglist . )
    (61) arglist -> arglist . , expr
    )               shift and go to state 120
    ,               shift and go to state 116


state 110

    (15) stmt -> IF ( expr ) . stmt
    (16) stmt -> IF ( expr ) . stmt ELSE stmt
    (12) stmt -> . { stmtlist }
    (13) stmt -> . expr
    (14) stmt -> . asgn
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . FOR ( expr ; expr ; expr ) stmt
    (18) stmt -> . WHILE ( expr ) stmt
    (19) stmt -> . PRINT prlist
    (20) stmt -> . PROCEDURE ( arglist )
    (21) stmt -> . RETURN expr
    (22) stmt -> . RETURN
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    (6) asgn -> . VAR MODEQ expr
    (7) asgn -> . VAR DIVEQ expr
    (8) asgn -> . VAR MULEQ expr
    (9) asgn -> . VAR SUBEQ expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR = expr
    {               shift and go to state 7
    IF              shift and go to state 10
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    PRINT           shift and go to state 14
    PROCEDURE       shift and go to state 15
    RETURN          shift and go to state 16
    VAR             shift and go to state 18
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 8
    stmt                           shift and go to state 121
    asgn                           shift and go to state 9

state 111

    (17) stmt -> FOR ( expr ; . expr ; expr ) stmt
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 122

state 112

    (18) stmt -> WHILE ( expr ) . stmt
    (12) stmt -> . { stmtlist }
    (13) stmt -> . expr
    (14) stmt -> . asgn
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . FOR ( expr ; expr ; expr ) stmt
    (18) stmt -> . WHILE ( expr ) stmt
    (19) stmt -> . PRINT prlist
    (20) stmt -> . PROCEDURE ( arglist )
    (21) stmt -> . RETURN expr
    (22) stmt -> . RETURN
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    (6) asgn -> . VAR MODEQ expr
    (7) asgn -> . VAR DIVEQ expr
    (8) asgn -> . VAR MULEQ expr
    (9) asgn -> . VAR SUBEQ expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR = expr
    {               shift and go to state 7
    IF              shift and go to state 10
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    PRINT           shift and go to state 14
    PROCEDURE       shift and go to state 15
    RETURN          shift and go to state 16
    VAR             shift and go to state 18
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 8
    stmt                           shift and go to state 123
    asgn                           shift and go to state 9

state 113

    (51) prlist -> prlist , STRING .
    ,               reduce using rule 51 (prlist -> prlist , STRING .)
    {               reduce using rule 51 (prlist -> prlist , STRING .)
    IF              reduce using rule 51 (prlist -> prlist , STRING .)
    FOR             reduce using rule 51 (prlist -> prlist , STRING .)
    WHILE           reduce using rule 51 (prlist -> prlist , STRING .)
    PRINT           reduce using rule 51 (prlist -> prlist , STRING .)
    PROCEDURE       reduce using rule 51 (prlist -> prlist , STRING .)
    RETURN          reduce using rule 51 (prlist -> prlist , STRING .)
    VAR             reduce using rule 51 (prlist -> prlist , STRING .)
    DEC             reduce using rule 51 (prlist -> prlist , STRING .)
    INC             reduce using rule 51 (prlist -> prlist , STRING .)
    NOT             reduce using rule 51 (prlist -> prlist , STRING .)
    -               reduce using rule 51 (prlist -> prlist , STRING .)
    (               reduce using rule 51 (prlist -> prlist , STRING .)
    BLTIN           reduce using rule 51 (prlist -> prlist , STRING .)
    READ            reduce using rule 51 (prlist -> prlist , STRING .)
    FUNCTION        reduce using rule 51 (prlist -> prlist , STRING .)
    NUMBER          reduce using rule 51 (prlist -> prlist , STRING .)
    PROC            reduce using rule 51 (prlist -> prlist , STRING .)
    FUNC            reduce using rule 51 (prlist -> prlist , STRING .)
    $end            reduce using rule 51 (prlist -> prlist , STRING .)
    }               reduce using rule 51 (prlist -> prlist , STRING .)
    ELSE            reduce using rule 51 (prlist -> prlist , STRING .)


state 114

    (52) prlist -> prlist , expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
  ! shift/reduce conflict for - resolved as shift
    ,               reduce using rule 52 (prlist -> prlist , expr .)
    {               reduce using rule 52 (prlist -> prlist , expr .)
    IF              reduce using rule 52 (prlist -> prlist , expr .)
    FOR             reduce using rule 52 (prlist -> prlist , expr .)
    WHILE           reduce using rule 52 (prlist -> prlist , expr .)
    PRINT           reduce using rule 52 (prlist -> prlist , expr .)
    PROCEDURE       reduce using rule 52 (prlist -> prlist , expr .)
    RETURN          reduce using rule 52 (prlist -> prlist , expr .)
    VAR             reduce using rule 52 (prlist -> prlist , expr .)
    DEC             reduce using rule 52 (prlist -> prlist , expr .)
    INC             reduce using rule 52 (prlist -> prlist , expr .)
    NOT             reduce using rule 52 (prlist -> prlist , expr .)
    (               reduce using rule 52 (prlist -> prlist , expr .)
    BLTIN           reduce using rule 52 (prlist -> prlist , expr .)
    READ            reduce using rule 52 (prlist -> prlist , expr .)
    FUNCTION        reduce using rule 52 (prlist -> prlist , expr .)
    NUMBER          reduce using rule 52 (prlist -> prlist , expr .)
    PROC            reduce using rule 52 (prlist -> prlist , expr .)
    FUNC            reduce using rule 52 (prlist -> prlist , expr .)
    $end            reduce using rule 52 (prlist -> prlist , expr .)
    }               reduce using rule 52 (prlist -> prlist , expr .)
    ELSE            reduce using rule 52 (prlist -> prlist , expr .)
    OR              shift and go to state 31
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 115

    (20) stmt -> PROCEDURE ( arglist ) .
    {               reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    IF              reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    FOR             reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    WHILE           reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    PRINT           reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    PROCEDURE       reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    RETURN          reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    VAR             reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    DEC             reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    INC             reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    NOT             reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    -               reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    (               reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    BLTIN           reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    READ            reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    FUNCTION        reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    NUMBER          reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    PROC            reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    FUNC            reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    $end            reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    }               reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)
    ELSE            reduce using rule 20 (stmt -> PROCEDURE ( arglist ) .)


state 116

    (61) arglist -> arglist , . expr
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 124

state 117

    (55) defn -> func_header ( ) stmt .
    {               reduce using rule 55 (defn -> func_header ( ) stmt .)
    IF              reduce using rule 55 (defn -> func_header ( ) stmt .)
    FOR             reduce using rule 55 (defn -> func_header ( ) stmt .)
    WHILE           reduce using rule 55 (defn -> func_header ( ) stmt .)
    PRINT           reduce using rule 55 (defn -> func_header ( ) stmt .)
    PROCEDURE       reduce using rule 55 (defn -> func_header ( ) stmt .)
    RETURN          reduce using rule 55 (defn -> func_header ( ) stmt .)
    VAR             reduce using rule 55 (defn -> func_header ( ) stmt .)
    DEC             reduce using rule 55 (defn -> func_header ( ) stmt .)
    INC             reduce using rule 55 (defn -> func_header ( ) stmt .)
    NOT             reduce using rule 55 (defn -> func_header ( ) stmt .)
    -               reduce using rule 55 (defn -> func_header ( ) stmt .)
    (               reduce using rule 55 (defn -> func_header ( ) stmt .)
    BLTIN           reduce using rule 55 (defn -> func_header ( ) stmt .)
    READ            reduce using rule 55 (defn -> func_header ( ) stmt .)
    FUNCTION        reduce using rule 55 (defn -> func_header ( ) stmt .)
    NUMBER          reduce using rule 55 (defn -> func_header ( ) stmt .)
    PROC            reduce using rule 55 (defn -> func_header ( ) stmt .)
    FUNC            reduce using rule 55 (defn -> func_header ( ) stmt .)
    $end            reduce using rule 55 (defn -> func_header ( ) stmt .)


state 118

    (46) expr -> BLTIN ( expr ) .
    OR              reduce using rule 46 (expr -> BLTIN ( expr ) .)
    AND             reduce using rule 46 (expr -> BLTIN ( expr ) .)
    NE              reduce using rule 46 (expr -> BLTIN ( expr ) .)
    EQ              reduce using rule 46 (expr -> BLTIN ( expr ) .)
    GE              reduce using rule 46 (expr -> BLTIN ( expr ) .)
    GT              reduce using rule 46 (expr -> BLTIN ( expr ) .)
    LE              reduce using rule 46 (expr -> BLTIN ( expr ) .)
    LT              reduce using rule 46 (expr -> BLTIN ( expr ) .)
    ^               reduce using rule 46 (expr -> BLTIN ( expr ) .)
    %               reduce using rule 46 (expr -> BLTIN ( expr ) .)
    /               reduce using rule 46 (expr -> BLTIN ( expr ) .)
    *               reduce using rule 46 (expr -> BLTIN ( expr ) .)
    -               reduce using rule 46 (expr -> BLTIN ( expr ) .)
    +               reduce using rule 46 (expr -> BLTIN ( expr ) .)
    {               reduce using rule 46 (expr -> BLTIN ( expr ) .)
    IF              reduce using rule 46 (expr -> BLTIN ( expr ) .)
    FOR             reduce using rule 46 (expr -> BLTIN ( expr ) .)
    WHILE           reduce using rule 46 (expr -> BLTIN ( expr ) .)
    PRINT           reduce using rule 46 (expr -> BLTIN ( expr ) .)
    PROCEDURE       reduce using rule 46 (expr -> BLTIN ( expr ) .)
    RETURN          reduce using rule 46 (expr -> BLTIN ( expr ) .)
    VAR             reduce using rule 46 (expr -> BLTIN ( expr ) .)
    DEC             reduce using rule 46 (expr -> BLTIN ( expr ) .)
    INC             reduce using rule 46 (expr -> BLTIN ( expr ) .)
    NOT             reduce using rule 46 (expr -> BLTIN ( expr ) .)
    (               reduce using rule 46 (expr -> BLTIN ( expr ) .)
    BLTIN           reduce using rule 46 (expr -> BLTIN ( expr ) .)
    READ            reduce using rule 46 (expr -> BLTIN ( expr ) .)
    FUNCTION        reduce using rule 46 (expr -> BLTIN ( expr ) .)
    NUMBER          reduce using rule 46 (expr -> BLTIN ( expr ) .)
    PROC            reduce using rule 46 (expr -> BLTIN ( expr ) .)
    FUNC            reduce using rule 46 (expr -> BLTIN ( expr ) .)
    $end            reduce using rule 46 (expr -> BLTIN ( expr ) .)
    )               reduce using rule 46 (expr -> BLTIN ( expr ) .)
    ,               reduce using rule 46 (expr -> BLTIN ( expr ) .)
    }               reduce using rule 46 (expr -> BLTIN ( expr ) .)
    ELSE            reduce using rule 46 (expr -> BLTIN ( expr ) .)
    ;               reduce using rule 46 (expr -> BLTIN ( expr ) .)


state 119

    (47) expr -> READ ( VAR ) .
    OR              reduce using rule 47 (expr -> READ ( VAR ) .)
    AND             reduce using rule 47 (expr -> READ ( VAR ) .)
    NE              reduce using rule 47 (expr -> READ ( VAR ) .)
    EQ              reduce using rule 47 (expr -> READ ( VAR ) .)
    GE              reduce using rule 47 (expr -> READ ( VAR ) .)
    GT              reduce using rule 47 (expr -> READ ( VAR ) .)
    LE              reduce using rule 47 (expr -> READ ( VAR ) .)
    LT              reduce using rule 47 (expr -> READ ( VAR ) .)
    ^               reduce using rule 47 (expr -> READ ( VAR ) .)
    %               reduce using rule 47 (expr -> READ ( VAR ) .)
    /               reduce using rule 47 (expr -> READ ( VAR ) .)
    *               reduce using rule 47 (expr -> READ ( VAR ) .)
    -               reduce using rule 47 (expr -> READ ( VAR ) .)
    +               reduce using rule 47 (expr -> READ ( VAR ) .)
    {               reduce using rule 47 (expr -> READ ( VAR ) .)
    IF              reduce using rule 47 (expr -> READ ( VAR ) .)
    FOR             reduce using rule 47 (expr -> READ ( VAR ) .)
    WHILE           reduce using rule 47 (expr -> READ ( VAR ) .)
    PRINT           reduce using rule 47 (expr -> READ ( VAR ) .)
    PROCEDURE       reduce using rule 47 (expr -> READ ( VAR ) .)
    RETURN          reduce using rule 47 (expr -> READ ( VAR ) .)
    VAR             reduce using rule 47 (expr -> READ ( VAR ) .)
    DEC             reduce using rule 47 (expr -> READ ( VAR ) .)
    INC             reduce using rule 47 (expr -> READ ( VAR ) .)
    NOT             reduce using rule 47 (expr -> READ ( VAR ) .)
    (               reduce using rule 47 (expr -> READ ( VAR ) .)
    BLTIN           reduce using rule 47 (expr -> READ ( VAR ) .)
    READ            reduce using rule 47 (expr -> READ ( VAR ) .)
    FUNCTION        reduce using rule 47 (expr -> READ ( VAR ) .)
    NUMBER          reduce using rule 47 (expr -> READ ( VAR ) .)
    PROC            reduce using rule 47 (expr -> READ ( VAR ) .)
    FUNC            reduce using rule 47 (expr -> READ ( VAR ) .)
    $end            reduce using rule 47 (expr -> READ ( VAR ) .)
    )               reduce using rule 47 (expr -> READ ( VAR ) .)
    ,               reduce using rule 47 (expr -> READ ( VAR ) .)
    }               reduce using rule 47 (expr -> READ ( VAR ) .)
    ELSE            reduce using rule 47 (expr -> READ ( VAR ) .)
    ;               reduce using rule 47 (expr -> READ ( VAR ) .)


state 120

    (48) expr -> FUNCTION ( arglist ) .
    OR              reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    AND             reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    NE              reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    EQ              reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    GE              reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    GT              reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    LE              reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    LT              reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    ^               reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    %               reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    /               reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    *               reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    -               reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    +               reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    {               reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    IF              reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    FOR             reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    WHILE           reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    PRINT           reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    PROCEDURE       reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    RETURN          reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    VAR             reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    DEC             reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    INC             reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    NOT             reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    (               reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    BLTIN           reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    READ            reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    FUNCTION        reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    NUMBER          reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    PROC            reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    FUNC            reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    $end            reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    )               reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    ,               reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    }               reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    ELSE            reduce using rule 48 (expr -> FUNCTION ( arglist ) .)
    ;               reduce using rule 48 (expr -> FUNCTION ( arglist ) .)


state 121

    (15) stmt -> IF ( expr ) stmt .
    (16) stmt -> IF ( expr ) stmt . ELSE stmt
  ! shift/reduce conflict for ELSE resolved as shift
    {               reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    FOR             reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    PRINT           reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    PROCEDURE       reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    VAR             reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    DEC             reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    INC             reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    NOT             reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    -               reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    (               reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    BLTIN           reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    READ            reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    FUNCTION        reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    NUMBER          reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    PROC            reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    FUNC            reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    $end            reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    }               reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    ELSE            shift and go to state 125


state 122

    (17) stmt -> FOR ( expr ; expr . ; expr ) stmt
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    ;               shift and go to state 126
    OR              shift and go to state 31
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 123

    (18) stmt -> WHILE ( expr ) stmt .
    {               reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    FOR             reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    PRINT           reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    PROCEDURE       reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    VAR             reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    DEC             reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    INC             reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    NOT             reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    -               reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    BLTIN           reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    READ            reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    FUNCTION        reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    NUMBER          reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    PROC            reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    FUNC            reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    $end            reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    }               reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 18 (stmt -> WHILE ( expr ) stmt .)


state 124

    (61) arglist -> arglist , expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    )               reduce using rule 61 (arglist -> arglist , expr .)
    ,               reduce using rule 61 (arglist -> arglist , expr .)
    OR              shift and go to state 31
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 125

    (16) stmt -> IF ( expr ) stmt ELSE . stmt
    (12) stmt -> . { stmtlist }
    (13) stmt -> . expr
    (14) stmt -> . asgn
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . FOR ( expr ; expr ; expr ) stmt
    (18) stmt -> . WHILE ( expr ) stmt
    (19) stmt -> . PRINT prlist
    (20) stmt -> . PROCEDURE ( arglist )
    (21) stmt -> . RETURN expr
    (22) stmt -> . RETURN
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    (6) asgn -> . VAR MODEQ expr
    (7) asgn -> . VAR DIVEQ expr
    (8) asgn -> . VAR MULEQ expr
    (9) asgn -> . VAR SUBEQ expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR = expr
    {               shift and go to state 7
    IF              shift and go to state 10
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    PRINT           shift and go to state 14
    PROCEDURE       shift and go to state 15
    RETURN          shift and go to state 16
    VAR             shift and go to state 18
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 8
    stmt                           shift and go to state 127
    asgn                           shift and go to state 9

state 126

    (17) stmt -> FOR ( expr ; expr ; . expr ) stmt
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    VAR             shift and go to state 47
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 128

state 127

    (16) stmt -> IF ( expr ) stmt ELSE stmt .
    {               reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    FOR             reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    PRINT           reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    PROCEDURE       reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    VAR             reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    DEC             reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    INC             reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    NOT             reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    BLTIN           reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    READ            reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    FUNCTION        reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    NUMBER          reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    PROC            reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    FUNC            reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    $end            reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    }               reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)


state 128

    (17) stmt -> FOR ( expr ; expr ; expr . ) stmt
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . NE expr
    (34) expr -> expr . EQ expr
    (35) expr -> expr . GE expr
    (36) expr -> expr . GT expr
    (37) expr -> expr . LE expr
    (38) expr -> expr . LT expr
    (39) expr -> expr . ^ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    )               shift and go to state 129
    OR              shift and go to state 31
    AND             shift and go to state 32
    NE              shift and go to state 33
    EQ              shift and go to state 34
    GE              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    LT              shift and go to state 38
    ^               shift and go to state 39
    %               shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 129

    (17) stmt -> FOR ( expr ; expr ; expr ) . stmt
    (12) stmt -> . { stmtlist }
    (13) stmt -> . expr
    (14) stmt -> . asgn
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . FOR ( expr ; expr ; expr ) stmt
    (18) stmt -> . WHILE ( expr ) stmt
    (19) stmt -> . PRINT prlist
    (20) stmt -> . PROCEDURE ( arglist )
    (21) stmt -> . RETURN expr
    (22) stmt -> . RETURN
    (25) expr -> . VAR DEC
    (26) expr -> . VAR INC
    (27) expr -> . DEC VAR
    (28) expr -> . INC VAR
    (29) expr -> . NOT expr
    (30) expr -> . - expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr NE expr
    (34) expr -> . expr EQ expr
    (35) expr -> . expr GE expr
    (36) expr -> . expr GT expr
    (37) expr -> . expr LE expr
    (38) expr -> . expr LT expr
    (39) expr -> . expr ^ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ( expr )
    (46) expr -> . BLTIN ( expr )
    (47) expr -> . READ ( VAR )
    (48) expr -> . FUNCTION ( arglist )
    (49) expr -> . VAR
    (50) expr -> . NUMBER
    (6) asgn -> . VAR MODEQ expr
    (7) asgn -> . VAR DIVEQ expr
    (8) asgn -> . VAR MULEQ expr
    (9) asgn -> . VAR SUBEQ expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR = expr
    {               shift and go to state 7
    IF              shift and go to state 10
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    PRINT           shift and go to state 14
    PROCEDURE       shift and go to state 15
    RETURN          shift and go to state 16
    VAR             shift and go to state 18
    DEC             shift and go to state 19
    INC             shift and go to state 20
    NOT             shift and go to state 21
    -               shift and go to state 22
    (               shift and go to state 11
    BLTIN           shift and go to state 23
    READ            shift and go to state 24
    FUNCTION        shift and go to state 25
    NUMBER          shift and go to state 26

    expr                           shift and go to state 8
    stmt                           shift and go to state 130
    asgn                           shift and go to state 9

state 130

    (17) stmt -> FOR ( expr ; expr ; expr ) stmt .
    {               reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    IF              reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    FOR             reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    WHILE           reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    PRINT           reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    PROCEDURE       reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    RETURN          reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    VAR             reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    DEC             reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    INC             reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    NOT             reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    -               reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    (               reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    BLTIN           reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    READ            reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    FUNCTION        reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    NUMBER          reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    PROC            reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    FUNC            reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    $end            reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    }               reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)
    ELSE            reduce using rule 17 (stmt -> FOR ( expr ; expr ; expr ) stmt .)


Conflicts:

shift/reduce conflict for - in state 8 resolved as shift
shift/reduce conflict for VAR in state 16 resolved as shift
shift/reduce conflict for DEC in state 16 resolved as shift
shift/reduce conflict for INC in state 16 resolved as shift
shift/reduce conflict for NOT in state 16 resolved as shift
shift/reduce conflict for - in state 16 resolved as shift
shift/reduce conflict for ( in state 16 resolved as shift
shift/reduce conflict for BLTIN in state 16 resolved as shift
shift/reduce conflict for READ in state 16 resolved as shift
shift/reduce conflict for FUNCTION in state 16 resolved as shift
shift/reduce conflict for NUMBER in state 16 resolved as shift
shift/reduce conflict for DEC in state 18 resolved as shift
shift/reduce conflict for INC in state 18 resolved as shift
shift/reduce conflict for DEC in state 47 resolved as shift
shift/reduce conflict for INC in state 47 resolved as shift
shift/reduce conflict for - in state 52 resolved as shift
shift/reduce conflict for - in state 54 resolved as shift
shift/reduce conflict for - in state 114 resolved as shift
shift/reduce conflict for ELSE in state 121 resolved as shift